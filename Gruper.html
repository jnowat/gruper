<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Multi-Agent AI Conversation System with Ollama - Production Grade">
    <title>Gruper v0.4.5 - Multi-Agent Conversation System</title>

    <!-- See CHANGELOG.md for full version history -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha384-FhvbTO3MY8s3Ke97TPkFNzEhFy9lwD+RJJN6VHKPqKST/XF3SVSLxZKqE0RXHQJ5" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js" integrity="sha384-9RLVjZXV+d8bkxJpLiJZPEtHvzPvV7L0m6cGLAkLhkLvLCxPMpYnhZKJYpWyv0xM" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha384-9nhczxUqK87bcKHh20fSQcTGD4qq5GhayNYSYWqwBkINBhOfQLg/P5HG5lF1urn4" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js" integrity="sha384-vdScihEZCfbPnBQf+lc7LgXUdJVYyhC3yWHUW5C5P5GpHRqVnaM6HJELJxT6IqwM" crossorigin="anonymous"></script>	

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        /* =================================================================
           GLASSMORPHISM v0.2.0 - Breathtaking Modern Design
           ================================================================= */
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --secondary: #a78bfa;
            --accent: #ec4899;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
            --text-primary: #0f172a;
            --text-secondary: #64748b;
            --bg-base: #f8fafc;
            --bg-glass: rgba(255, 255, 255, 0.7);
            --border-glass: rgba(255, 255, 255, 0.3);
            --shadow-glow: 0 8px 32px rgba(99, 102, 241, 0.15);
            --shadow-lift: 0 20px 60px rgba(99, 102, 241, 0.25);
            --radius: 16px;
            --transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --font-scale: 1; /* v0.4.1: Global text scale control */
        }
        
        /* Dark Mode - Dark First Design */
        body.dark-mode {
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --bg-base: #0f172a;
            --bg-glass: rgba(15, 23, 42, 0.7);
            --border-glass: rgba(148, 163, 184, 0.1);
            --shadow-glow: 0 8px 32px rgba(99, 102, 241, 0.3);
            --shadow-lift: 0 20px 60px rgba(99, 102, 241, 0.4);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            overflow: hidden;
            transition: all 0.5s ease, font-size 0.2s ease; /* v0.4.2: Smooth text scaling */
            position: relative;
            font-size: calc(16px * var(--font-scale)); /* v0.4.1: Text scaling */
        }

        /* v0.3.0: Floating nebula particles background */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(120, 219, 226, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(251, 113, 133, 0.15) 0%, transparent 50%);
            pointer-events: none;
            animation: float 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-30px) rotate(1deg); }
        }

        body.dark-mode {
            background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #1e293b 100%);
        }

        body.dark-mode::before {
            background: radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.4) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(167, 139, 250, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(236, 72, 153, 0.2) 0%, transparent 50%);
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition: none !important;
            }
        }

        /* =================================================================
           ANIMATED GRADIENT HEADER WITH SHIMMER
           ================================================================= */
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        /* =================================================================
           GLASS CONTAINER
           ================================================================= */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-glow),
                        0 0 0 1px var(--border-glass) inset;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
            border: 1px solid var(--border-glass);
        }
        
        /* =================================================================
           VIBRANT ANIMATED GRADIENT HEADER
           ================================================================= */
        .header {
            background: linear-gradient(135deg, 
                var(--primary) 0%, 
                var(--secondary) 50%, 
                var(--accent) 100%);
            background-size: 200% 200%;
            animation: gradientShift 8s ease infinite;
            color: white;
            padding: 24px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 50%,
                transparent 100%
            );
            background-size: 200% 100%;
            animation: shimmer 3s linear infinite;
            pointer-events: none;
        }

        body.dark-mode .header {
            background: linear-gradient(135deg, 
                #1e1b4b 0%, 
                #4c1d95 50%, 
                #831843 100%);
            background-size: 200% 200%;
            animation: gradientShift 8s ease infinite;
        }
        
        .header-left h1 { 
            font-size: 1.6em; 
            margin-bottom: 4px;
            font-weight: 700;
            position: relative;
            z-index: 1;
        }
        
        .header-left p { 
            opacity: 0.95; 
            font-size: 0.85em;
            position: relative;
            z-index: 1;
        }
        
        .header-right {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }
        
        /* =================================================================
           LAYOUT COMPONENTS
           ================================================================= */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        /* =================================================================
           FLOATING GLASS SIDEBAR
           ================================================================= */
        .sidebar {
            width: 380px;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-right: 1px solid var(--border-glass);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            transition: all var(--transition);
            flex-shrink: 0;
            position: relative;
        }
        
        .sidebar.collapsed {
            width: 50px;
            padding: 20px 5px;
        }
        
        .sidebar.collapsed .sidebar-content {
            opacity: 0;
            pointer-events: none;
        }
        
        .sidebar-content {
            transition: opacity var(--transition);
            opacity: 1;
        }
        
        .sidebar-toggle {
            position: absolute;
            top: 50%;
            right: -16px;
            transform: translateY(-50%);
            width: 32px;
            height: 64px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 0 12px 12px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            z-index: 100;
            transition: all var(--transition);
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4);
        }

        .sidebar-toggle:hover {
            background: var(--primary-light);
            transform: translateY(-50%) translateX(2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }

        .sidebar-toggle:active {
            transform: translateY(-50%) scale(0.95);
        }

        .sidebar-toggle-icon {
            transition: transform var(--transition);
            display: inline-block;
        }

        .sidebar.collapsed .sidebar-toggle-icon {
            transform: rotate(180deg);
        }
        
        .conversation-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }

        /* =================================================================
           TAB SYSTEM WITH GLASS EFFECT
           ================================================================= */
        .tabs-container {
            display: flex;
            align-items: center;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-glass);
            padding: 8px 15px;
            gap: 8px;
            overflow-x: auto;
            flex-shrink: 0;
        }
        
        .tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-glass);
            border-radius: 12px;
            cursor: pointer;
            transition: all var(--transition);
            white-space: nowrap;
            font-size: 0.9em;
            font-weight: 500;
        }
        
        body.dark-mode .tab {
            background: rgba(15, 23, 42, 0.5);
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.7);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        body.dark-mode .tab:hover {
            background: rgba(15, 23, 42, 0.7);
        }
        
        .tab.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4);
        }
        
        .tab-close {
            padding: 2px 6px;
            margin-left: 4px;
            border-radius: 6px;
            opacity: 0.8;
            transition: all var(--transition);
        }
        
        .tab-close:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .new-tab-btn {
            padding: 10px 18px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all var(--transition);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .new-tab-btn:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        /* =================================================================
           STATUS BAR
           ================================================================= */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-glass);
            flex-wrap: wrap;
            gap: 15px;
            flex-shrink: 0;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--danger);
            animation: pulse 2s infinite;
            box-shadow: 0 0 12px currentColor;
        }
        
        .status-dot.connected {
            background: var(--success);
            animation: none;
        }
        
        .status-dot.checking {
            background: var(--warning);
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }
        
        /* v0.4.0: Enhanced contrast for health indicators */
        .health-indicator {
            font-size: 0.85em;
            padding: 6px 12px;
            border-radius: 12px;
            font-weight: 600;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .health-good {
            background: rgba(16, 185, 129, 0.25);
            color: #059669;
            border: 1px solid rgba(16, 185, 129, 0.5);
        }

        body.dark-mode .health-good {
            background: rgba(16, 185, 129, 0.3);
            color: #10b981;
            border-color: rgba(16, 185, 129, 0.6);
        }

        .health-warning {
            background: rgba(245, 158, 11, 0.25);
            color: #d97706;
            border: 1px solid rgba(245, 158, 11, 0.5);
        }

        body.dark-mode .health-warning {
            background: rgba(245, 158, 11, 0.3);
            color: #f59e0b;
            border-color: rgba(245, 158, 11, 0.6);
        }

        .health-bad {
            background: rgba(239, 68, 68, 0.25);
            color: #dc2626;
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        body.dark-mode .health-bad {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.6);
        }

        /* =================================================================
           FLOATING GLASS CARDS FOR MESSAGES
           ================================================================= */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: transparent;
            scroll-behavior: smooth;
        }
        
        .message {
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: var(--shadow-glow),
                        0 0 0 1px var(--border-glass) inset;
            transition: all var(--transition);
            position: relative;
            border: 1px solid var(--border-glass);
            /* v0.3.0: Entrance animation */
            animation: messageIn 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }

        @keyframes messageIn {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .message:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lift),
                        0 0 0 1px var(--border-glass) inset;
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .message-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .agent-label {
            font-weight: 700;
            font-size: 1.05em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* =================================================================
           GLOWING RAINBOW RING AVATARS
           ================================================================= */
        @keyframes rotate-ring {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes rainbow-glow {
            0%, 100% { filter: hue-rotate(0deg) drop-shadow(0 0 8px currentColor); }
            50% { filter: hue-rotate(360deg) drop-shadow(0 0 16px currentColor); }
        }

        .agent-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            font-size: 0.9em;
            position: relative;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4);
        }

        .agent-avatar::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                #6366f1,
                #a78bfa,
                #ec4899,
                #f59e0b,
                #10b981,
                #3b82f6,
                #6366f1
            );
            animation: rotate-ring 4s linear infinite;
            z-index: -1;
        }

        .agent-avatar::after {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: inherit;
            filter: blur(8px);
            opacity: 0.6;
            z-index: -2;
            animation: rainbow-glow 4s ease-in-out infinite;
        }
        
        /* Agent Colors */
        .agent-1-label { color: #6366f1; }
        .agent-2-label { color: #a78bfa; }
        .agent-3-label { color: #ec4899; }
        .agent-4-label { color: #14b8a6; }
        .agent-5-label { color: #f59e0b; }
        .agent-6-label { color: #3b82f6; }

        .agent-1-avatar { background: linear-gradient(135deg, #6366f1, #818cf8); }
        .agent-2-avatar { background: linear-gradient(135deg, #a78bfa, #c4b5fd); }
        .agent-3-avatar { background: linear-gradient(135deg, #ec4899, #f472b6); }
        .agent-4-avatar { background: linear-gradient(135deg, #14b8a6, #5eead4); }
        .agent-5-avatar { background: linear-gradient(135deg, #f59e0b, #fbbf24); }
        .agent-6-avatar { background: linear-gradient(135deg, #3b82f6, #60a5fa); }
        
        /* v0.4.0: Enhanced contrast for badges */
        .round-badge {
            font-size: 0.8em;
            padding: 4px 12px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            font-weight: 600;
            border: 1px solid rgba(99, 102, 241, 0.4);
            color: var(--primary);
        }

        body.dark-mode .round-badge {
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(99, 102, 241, 0.5);
            color: var(--primary-light);
        }

        .response-time-badge {
            font-size: 0.75em;
            padding: 4px 10px;
            background: rgba(99, 102, 241, 0.2);
            color: var(--primary);
            border-radius: 10px;
            font-weight: 600;
            border: 1px solid rgba(99, 102, 241, 0.4);
        }

        body.dark-mode .response-time-badge {
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(99, 102, 241, 0.5);
            color: var(--primary-light);
        }
        
        .message-actions {
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity var(--transition);
        }
        
        .message:hover .message-actions {
            opacity: 1;
        }
        
        .message-action-btn {
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.2);
            padding: 6px 10px;
            cursor: pointer;
            transition: all var(--transition);
            font-size: 1em;
            color: var(--text-primary);
            border-radius: 8px;
        }
        
        .message-action-btn:hover {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }
        
        .message-content {
            line-height: 1.7;
            color: var(--text-primary);
            white-space: pre-wrap;
            word-wrap: break-word;
            /* v0.4.0: Semi-opaque backdrop for better text contrast */
            background: rgba(255, 255, 255, 0.88);
            padding: 12px;
            border-radius: 8px;
        }

        body.dark-mode .message-content {
            background: rgba(15, 23, 42, 0.88);
        }
        
        .memory-indicator {
            display: inline-block;
            padding: 4px 10px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 10px;
            font-size: 0.75em;
            margin-left: 8px;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        /* v0.4.5: Minimal round summary badge */
        .round-summary-badge {
            text-align: center;
            padding: 8px 16px;
            margin: 12px 0;
            font-size: 0.85em;
            color: var(--text-secondary);
            background: var(--bg-glass);
            border-radius: 20px;
            border: 1px solid var(--border-glass);
            backdrop-filter: blur(8px);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .thinking-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 18px;
            background: linear-gradient(135deg, var(--warning), #fbbf24);
            color: white;
            border-radius: 12px;
            font-weight: 600;
            margin: 10px 0;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.3);
        }
        
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ── v0.4.0: SKELETON LOADING STATES ────────────────────────────── */
        .skeleton-message {
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: var(--shadow-glow),
                        0 0 0 1px var(--border-glass) inset;
            border: 1px solid var(--border-glass);
            animation: messageIn 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .skeleton-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .skeleton-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(90deg,
                rgba(99, 102, 241, 0.1) 0%,
                rgba(99, 102, 241, 0.2) 50%,
                rgba(99, 102, 241, 0.1) 100%);
            background-size: 200% 100%;
            animation: shimmerSkeleton 1.5s ease-in-out infinite;
        }

        .skeleton-line {
            height: 14px;
            background: linear-gradient(90deg,
                rgba(99, 102, 241, 0.1) 0%,
                rgba(99, 102, 241, 0.2) 50%,
                rgba(99, 102, 241, 0.1) 100%);
            background-size: 200% 100%;
            border-radius: 8px;
            margin-bottom: 10px;
            animation: shimmerSkeleton 1.5s ease-in-out infinite;
        }

        .skeleton-line.short {
            width: 70%;
        }

        /* v0.4.2: Skeleton progress text for long waits */
        .skeleton-progress {
            margin-top: 12px;
            font-size: 0.85em;
            color: var(--text-secondary);
            font-style: italic;
        }

        @keyframes shimmerSkeleton {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .scroll-bottom-btn {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            transition: all var(--transition);
            z-index: 100;
        }
        
        .scroll-bottom-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 8px 24px rgba(99, 102, 241, 0.5);
        }

        /* =================================================================
           CONTROL PANEL & ACTION BUTTONS WITH DEPTH
           ================================================================= */
        .action-buttons-panel {
            padding: 12px 20px;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-top: 1px solid var(--border-glass);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .control-panel {
            padding: 20px;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-top: 1px solid var(--border-glass);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            flex-shrink: 0;
        }
        
        .task-input-container {
            flex: 1;
            min-width: 300px;
        }
        
        .task-input {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--border-glass);
            border-radius: var(--radius);
            font-size: 1em;
            transition: all var(--transition);
            resize: vertical;
            min-height: 150px;
            max-height: 400px;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: var(--text-primary);
        }
        
        .task-input:focus {
            outline: none;
            border-color: var(--primary);
            /* v0.3.0: Premium glowing focus ring */
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.2),
                        0 4px 24px rgba(99, 102, 241, 0.3),
                        0 0 40px rgba(99, 102, 241, 0.1);
            animation: focusGlow 2s ease-in-out infinite;
        }

        @keyframes focusGlow {
            0%, 100% {
                box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.2),
                            0 4px 24px rgba(99, 102, 241, 0.3),
                            0 0 40px rgba(99, 102, 241, 0.1);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.3),
                            0 4px 24px rgba(99, 102, 241, 0.4),
                            0 0 40px rgba(99, 102, 241, 0.2);
            }
        }

        /* =================================================================
           ENHANCED BUTTONS WITH GLOW & DEPTH
           ================================================================= */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: var(--radius);
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4);
        }

        .btn-primary:hover:not(:disabled) {
            box-shadow: 0 6px 24px rgba(99, 102, 241, 0.5);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success), #059669);
            color: white;
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.4);
        }

        /* v0.3.0: Pulsing glow on Start button when ready */
        .btn-success:not(:disabled) {
            animation: pulseGlow 2s infinite;
        }

        @keyframes pulseGlow {
            0%, 100% {
                box-shadow: 0 4px 16px rgba(16, 185, 129, 0.4);
            }
            50% {
                box-shadow: 0 4px 32px rgba(16, 185, 129, 0.7),
                            0 0 40px rgba(16, 185, 129, 0.3);
            }
        }

        .btn-success:hover:not(:disabled) {
            box-shadow: 0 6px 24px rgba(16, 185, 129, 0.5);
            animation: none;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #dc2626);
            color: white;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
        }

        .btn-danger:hover:not(:disabled) {
            box-shadow: 0 6px 24px rgba(239, 68, 68, 0.5);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, var(--warning), #d97706);
            color: white;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.4);
        }

        .btn-warning:hover:not(:disabled) {
            box-shadow: 0 6px 24px rgba(245, 158, 11, 0.5);
        }
        
        .btn-info {
            background: linear-gradient(135deg, var(--info), #2563eb);
            color: white;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
        }

        .btn-info:hover:not(:disabled) {
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.5);
        }
        
        .btn-secondary {
            background: rgba(100, 116, 139, 0.8);
            color: white;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        .btn-sm {
            padding: 8px 16px;
            font-size: 0.85em;
        }
        
        .btn-xs {
            padding: 6px 12px;
            font-size: 0.75em;
        }

        /* =================================================================
           GLASS SIDEBAR SECTIONS
           ================================================================= */
        .sidebar-section {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: var(--radius);
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05),
                        0 0 0 1px var(--border-glass) inset;
            border: 1px solid var(--border-glass);
        }
        
        body.dark-mode .sidebar-section {
            background: rgba(15, 23, 42, 0.5);
        }
        
        .section-header {
            font-size: 1em;
            font-weight: 700;
            margin-bottom: 12px;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 6px 8px;
            border-radius: 8px;
            transition: all var(--transition);
        }
        
        .section-header:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        
        .section-header .collapse-icon {
            transition: transform var(--transition);
            font-size: 0.8em;
        }
        
        .section-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }
        
        .section-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height var(--transition), opacity var(--transition);
            opacity: 1;
        }
        
        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        .form-group {
            margin-bottom: 14px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85em;
        }
        
        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-glass);
            border-radius: 10px;
            font-size: 0.9em;
            transition: all var(--transition);
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            color: var(--text-primary);
        }
        
        body.dark-mode .form-input {
            background: rgba(15, 23, 42, 0.5);
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1),
                        0 2px 8px rgba(99, 102, 241, 0.2);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }
        
        .checkbox-input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* =================================================================
           AGENT CARDS WITH GLASS EFFECT
           ================================================================= */
        .agent-card {
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-glass);
            border-radius: var(--radius);
            padding: 16px;
            margin-bottom: 12px;
            transition: all var(--transition);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        body.dark-mode .agent-card {
            background: rgba(15, 23, 42, 0.4);
        }

        .agent-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.2);
        }
        
        .agent-card.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1),
                        0 4px 16px rgba(99, 102, 241, 0.2);
        }
        
        .agent-card.disabled {
            opacity: 0.6;
        }
        
        .agent-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .agent-card-title {
            font-weight: 700;
            font-size: 0.95em;
            flex: 1;
        }
        
        .agent-advanced-toggle {
            font-size: 0.75em;
            padding: 6px 10px;
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition);
            font-weight: 600;
        }
        
        .agent-advanced-toggle:hover {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }
        
        .agent-advanced-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition);
            border-top: 1px solid var(--border-glass);
            padding-top: 0;
            margin-top: 0;
        }
        
        .agent-advanced-section.expanded {
            max-height: 1000px;
            padding-top: 12px;
            margin-top: 12px;
        }
        
        /* Slider Controls */
        .slider-control {
            margin: 12px 0;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .slider-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        .slider-value {
            font-size: 0.8em;
            font-weight: 700;
            color: var(--primary);
            padding: 3px 10px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(99, 102, 241, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: all var(--transition);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.5);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
        }

        /* Advanced parameter inputs */
        .input-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .input-group .form-input {
            flex: 1;
        }
        
        .input-addon {
            font-size: 0.8em;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        /* =================================================================
           ENHANCED MODALS & TOASTS
           ================================================================= */
        .command-palette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding-top: 100px;
            z-index: 1000;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        .command-palette-overlay.active {
            display: flex;
        }
        
        .command-palette {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lift),
                        0 0 0 1px var(--border-glass) inset;
            width: 600px;
            max-width: 90%;
            max-height: 500px;
            display: flex;
            flex-direction: column;
            animation: slideDown 0.3s ease;
            border: 1px solid var(--border-glass);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .command-search {
            padding: 20px;
            border-bottom: 1px solid var(--border-glass);
        }
        
        .command-search input {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--border-glass);
            border-radius: 12px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            color: var(--text-primary);
        }
        
        body.dark-mode .command-search input {
            background: rgba(15, 23, 42, 0.5);
        }
        
        .command-results {
            overflow-y: auto;
            max-height: 400px;
        }
        
        .command-item {
            padding: 14px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all var(--transition);
        }
        
        .command-item:hover,
        .command-item.selected {
            background: rgba(99, 102, 241, 0.1);
        }
        
        .command-icon {
            font-size: 1.3em;
            width: 28px;
        }
        
        .command-details {
            flex: 1;
        }
        
        .command-title {
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .command-description {
            font-size: 0.85em;
            color: var(--text-secondary);
        }
        
        .command-shortcut {
            font-size: 0.75em;
            padding: 4px 8px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 6px;
            color: var(--primary);
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        /* Analytics & Insights */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: rgba(99, 102, 241, 0.05);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 18px;
            border-radius: var(--radius);
            text-align: center;
            border: 1px solid rgba(99, 102, 241, 0.1);
        }
        
        .stat-value {
            font-size: 2.2em;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 20px;
            border-radius: var(--radius);
            margin-bottom: 15px;
            border: 1px solid var(--border-glass);
        }
        
        body.dark-mode .chart-container {
            background: rgba(15, 23, 42, 0.3);
        }

        /* TOAST NOTIFICATIONS WITH GLOW */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 400px;
        }
        
        .toast {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lift),
                        0 0 0 1px var(--border-glass) inset;
            padding: 18px;
            min-width: 320px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: toastIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            border: 1px solid var(--border-glass);
        }
        
        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateX(100%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        .toast.removing {
            animation: toastOut 0.3s ease;
        }
        
        @keyframes toastOut {
            to {
                opacity: 0;
                transform: translateX(100%) scale(0.8);
            }
        }
        
        .toast-icon {
            font-size: 1.6em;
            flex-shrink: 0;
        }
        
        .toast-content {
            flex: 1;
        }
        
        .toast-title {
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .toast-message {
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        .toast-close {
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.6;
            font-size: 1.3em;
            padding: 0;
            width: 28px;
            height: 28px;
            flex-shrink: 0;
            color: var(--text-primary);
            transition: all var(--transition);
        }
        
        .toast-close:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .toast.success {
            border-left: 4px solid var(--success);
            box-shadow: var(--shadow-lift),
                        0 0 20px rgba(16, 185, 129, 0.2);
        }

        /* v0.4.2: Prominent consensus toast */
        .toast.consensus {
            border: 3px solid var(--success);
            box-shadow: var(--shadow-lift),
                        0 0 32px rgba(16, 185, 129, 0.4);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
            box-shadow: var(--shadow-lift),
                        0 0 20px rgba(239, 68, 68, 0.2);
        }
        .toast.warning {
            border-left: 4px solid var(--warning);
            box-shadow: var(--shadow-lift),
                        0 0 20px rgba(245, 158, 11, 0.2);
        }
        .toast.info {
            border-left: 4px solid var(--info);
            box-shadow: var(--shadow-lift),
                        0 0 20px rgba(59, 130, 246, 0.2);
        }

        /* MODAL DIALOGS WITH GLASS */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lift),
                        0 0 0 1px var(--border-glass) inset;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            animation: modalIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid var(--border-glass);
        }
        
        @keyframes modalIn {
            from {
                opacity: 0;
                transform: scale(0.85);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-glass);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 1.4em;
            font-weight: 700;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.6em;
            cursor: pointer;
            opacity: 0.6;
            transition: all var(--transition);
            color: var(--text-primary);
        }
        
        .modal-close:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }
        
        .modal-footer {
            padding: 18px 24px;
            border-top: 1px solid var(--border-glass);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Agent Templates */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        
        .template-card {
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 2px solid var(--border-glass);
            border-radius: var(--radius);
            padding: 18px;
            cursor: pointer;
            transition: all var(--transition);
            text-align: center;
        }
        
        body.dark-mode .template-card {
            background: rgba(15, 23, 42, 0.4);
        }
        
        .template-card:hover {
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
        }
        
        .template-icon {
            font-size: 2.8em;
            margin-bottom: 12px;
        }
        
        .template-name {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 1.05em;
        }
        
        .template-description {
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        /* Search & Filter */
        .search-bar {
            position: sticky;
            top: 0;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px;
            border-bottom: 1px solid var(--border-glass);
            z-index: 10;
        }

        .search-input-wrapper {
            position: relative;
            width: 100%;
        }

        .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2em;
            opacity: 0.5;
        }

        .search-input-wrapper input {
            width: 100%;
            padding: 12px 45px;
            border: 2px solid var(--border-glass);
            border-radius: 12px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            color: var(--text-primary);
            transition: all var(--transition);
        }

        body.dark-mode .search-input-wrapper input {
            background: rgba(15, 23, 42, 0.5);
        }

        .search-input-wrapper input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .search-clear {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.4em;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity var(--transition);
            color: var(--text-primary);
        }

        .search-clear:hover {
            opacity: 1;
        }

        /* Progress Bars */
        .progress-container {
            padding: 15px 20px;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-glass);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 10px;
            transition: width 0.3s ease;
            box-shadow: 0 0 12px rgba(99, 102, 241, 0.5);
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        /* Debug Log Panel */
        .debug-log-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 2px solid var(--primary);
            transform: translateY(100%);
            transition: transform var(--transition);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
            resize: vertical; /* v0.4.1: Allow vertical resize */
            min-height: 200px;
            max-height: 80vh;
        }

        .debug-log-panel.active {
            transform: translateY(0);
        }

        /* v0.4.1: Resize handle for debug log */
        .resize-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(to bottom, rgba(99, 102, 241, 0.3), transparent);
            cursor: ns-resize;
            z-index: 10;
        }

        .resize-handle:hover {
            background: linear-gradient(to bottom, rgba(99, 102, 241, 0.6), transparent);
        }

        .debug-log-header {
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-log-title {
            font-weight: 700;
            font-size: 1.1em;
        }

        .debug-log-controls {
            display: flex;
            gap: 8px;
        }

        .debug-log-controls button {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all var(--transition);
        }

        .debug-log-controls button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* v0.4.2: Debug filter controls */
        .debug-controls {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        #debugSearch {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            font-size: 0.9em;
        }

        body.dark-mode #debugSearch {
            background: rgba(0, 0, 0, 0.2);
            color: white;
        }

        #debugSearch:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        .debug-controls label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            color: var(--text-primary);
            cursor: pointer;
            user-select: none;
        }

        body.dark-mode .debug-controls label {
            color: white;
        }

        #debugAutoScroll {
            cursor: pointer;
        }

        #debugLogContent {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85em;
        }

        .debug-entry {
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border-radius: 8px;
            border-left: 3px solid var(--primary);
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        body.dark-mode .debug-entry {
            background: rgba(15, 23, 42, 0.4);
        }

        .debug-timestamp {
            color: var(--text-secondary);
            font-size: 0.9em;
            min-width: 80px;
        }

        .debug-level {
            font-weight: 700;
            text-transform: uppercase;
            min-width: 70px;
            font-size: 0.85em;
        }

        .debug-level.debug { color: var(--text-secondary); }
        .debug-level.info { color: var(--info); }
        .debug-level.warning { color: var(--warning); }
        .debug-level.error { color: var(--danger); }
        .debug-level.success { color: var(--success); }

        .debug-message {
            flex: 1;
            color: var(--text-primary);
        }

        .debug-data {
            margin-top: 6px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 6px;
            font-size: 0.9em;
            color: var(--text-secondary);
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Tooltips */
        .tooltip-wrapper {
            position: relative;
            display: inline-block;
        }

        .tooltip {
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition);
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(15, 23, 42, 0.95);
        }

        .tooltip-wrapper:hover .tooltip {
            opacity: 1;
        }

        .tooltip-icon {
            cursor: help;
            opacity: 0.6;
            transition: opacity var(--transition);
            margin-left: 4px;
        }

        .tooltip-icon:hover {
            opacity: 1;
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .flex-1 { flex: 1; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .gap-1 { gap: 8px; }
        .gap-2 { gap: 16px; }
        .mb-1 { margin-bottom: 8px; }
        .mb-2 { margin-bottom: 16px; }
        .mt-1 { margin-top: 8px; }
        .text-muted { color: var(--text-secondary); }
        .text-center { text-align: center; }

        /* Kbd styling for keyboard shortcuts */
        kbd {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border-radius: 6px;
            border: 1px solid var(--border-glass);
            font-family: 'Inter', sans-serif;
            font-size: 0.9em;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode kbd {
            background: rgba(15, 23, 42, 0.8);
            color: var(--text-primary);
        }

        /* =================================================================
           v0.3.0: MINIMIZABLE PROMPT PANEL
           ================================================================= */
        .prompt-panel-minimized {
            max-height: 60px !important;
            overflow: hidden;
        }

        .prompt-panel-minimized .task-input {
            opacity: 0.3;
            pointer-events: none;
        }

        .minimize-prompt-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background: rgba(99, 102, 241, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition);
            z-index: 10;
            font-size: 1.2em;
        }

        .minimize-prompt-btn:hover {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
            transform: scale(1.1);
        }

        /* =================================================================
           v0.3.0: CUSTOM GLASS CONFIRMATION MODAL
           ================================================================= */
        .confirm-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            animation: fadeIn 0.2s ease;
        }

        .confirm-modal-overlay.active {
            display: flex;
        }

        .confirm-modal {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius);
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lift),
                        0 0 0 1px var(--border-glass) inset;
            border: 1px solid var(--border-glass);
            animation: modalSlideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .confirm-modal-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 16px;
        }

        .confirm-modal-title {
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 12px;
            text-align: center;
            color: var(--text-primary);
        }

        .confirm-modal-message {
            font-size: 1em;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .confirm-modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        /* =================================================================
           v0.3.0: ANIMATED AI ORB (placeholder replacement)
           ================================================================= */
        .ai-orb {
            display: inline-block;
            animation: float 6s ease-in-out infinite;
        }

        .ai-orb svg {
            filter: drop-shadow(0 8px 24px rgba(99, 102, 241, 0.4));
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(99, 102, 241, 0.5);
        }

        body.dark-mode ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        /* v0.4.2: Version badge in footer */
        .version-badge {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 6px 12px;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 8px;
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-secondary);
            border: 1px solid var(--border-glass);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 50;
            opacity: 0.7;
            transition: opacity var(--transition);
        }

        .version-badge:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer" role="alert" aria-live="polite"></div>

    <div class="command-palette-overlay" id="commandPaletteOverlay">
        <div class="command-palette">
            <div class="command-search">
                <input type="text" id="commandSearch" placeholder="Type a command or search..." autocomplete="off">
            </div>
            <div class="command-results" id="commandResults"></div>
        </div>
    </div>

    <div class="modal-overlay" id="analyticsModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">📊 Analytics Dashboard</div>
                <button class="modal-close" onclick="closeModal('analyticsModal')" aria-label="Close analytics modal">×</button>
            </div>
            <div class="modal-body">
                <div class="analytics-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalRounds">0</div>
                        <div class="stat-label">Total Rounds</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalMessages">0</div>
                        <div class="stat-label">Messages</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgResponseTime">0s</div>
                        <div class="stat-label">Avg Response</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="successRate">0%</div>
                        <div class="stat-label">Success Rate</div>
                    </div>
                </div>
                <!-- ── v0.4.0: CHART.JS ANALYTICS CHARTS ── -->
                <div class="chart-container">
                    <h4>Response Time Trend Across Rounds</h4>
                    <canvas id="responseTrendChart"></canvas>
                </div>
                <div class="chart-container">
                    <h4>Average Response Time by Agent</h4>
                    <canvas id="responseTimesChart"></canvas>
                </div>
                <!-- v0.4.1: Success Rate Pie Chart -->
                <div class="chart-container">
                    <h4>Success Rate (Success vs Failure)</h4>
                    <canvas id="successRateChart"></canvas>
                </div>
                <div class="chart-container">
                    <h4>Performance Summary</h4>
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 10px;">
                            <strong>Total Attempts:</strong> <span id="totalAttempts">0</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>Successful:</strong> <span id="successCount">0</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>Failed:</strong> <span id="failureCount">0</span>
                        </div>
                        <div>
                            <strong>Circuit Breaker Status:</strong> <span id="circuitStatus">Closed</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('analyticsModal')">Close</button>
                <button class="btn btn-primary" onclick="exportAnalytics()">Export Data</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="templatesModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">🎭 Agent Templates</div>
                <button class="modal-close" onclick="closeModal('templatesModal')" aria-label="Close templates modal">×</button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-2">Select a template to apply to Agent <span id="templateAgentNumber"></span></p>
                <div class="template-grid">
                    <div class="template-card" onclick="applyTemplate('analyst')">
                        <div class="template-icon">📊</div>
                        <div class="template-name">Analyst</div>
                        <div class="template-description">Data-driven, logical, methodical</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('creative')">
                        <div class="template-icon">🎨</div>
                        <div class="template-name">Creative</div>
                        <div class="template-description">Innovative, imaginative, bold</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('critic')">
                        <div class="template-icon">🔍</div>
                        <div class="template-name">Critic</div>
                        <div class="template-description">Skeptical, questioning, thorough</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('synthesizer')">
                        <div class="template-icon">🔗</div>
                        <div class="template-name">Synthesizer</div>
                        <div class="template-description">Integrative, balanced, diplomatic</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('expert')">
                        <div class="template-icon">🎓</div>
                        <div class="template-name">Expert</div>
                        <div class="template-description">Knowledgeable, precise, authoritative</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('devil')">
                        <div class="template-icon">😈</div>
                        <div class="template-name">Devil's Advocate</div>
                        <div class="template-description">Contrarian, challenging, provocative</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('philosopher')">
                        <div class="template-icon">🤔</div>
                        <div class="template-name">Philosopher</div>
                        <div class="template-description">Examines the 'why', principles, and ethics.</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('economist')">
                        <div class="template-icon">📈</div>
                        <div class="template-name">Economist</div>
                        <div class="template-description">Analyzes incentives, costs, and market impact.</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('ethicist')">
                        <div class="template-icon">📜</div>
                        <div class="template-name">Ethicist</div>
                        <div class="template-description">Evaluates fairness, rights, and moral dimensions.</div>
                    </div>
                    <!-- ── v0.4.0: NEW AGENT TEMPLATES ── -->
                    <div class="template-card" onclick="applyTemplate('scientist')">
                        <div class="template-icon">🔬</div>
                        <div class="template-name">Scientist</div>
                        <div class="template-description">Empirical, hypothesis-testing, evidence-based</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('psychologist')">
                        <div class="template-icon">🧠</div>
                        <div class="template-name">Psychologist</div>
                        <div class="template-description">Behavioral, motivational, bias-aware</div>
                    </div>
                    <div class="template-card" onclick="applyTemplate('engineer')">
                        <div class="template-icon">⚙️</div>
                        <div class="template-name">Engineer</div>
                        <div class="template-description">Practical, technical, optimization-focused</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('templatesModal')">Cancel</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- ── v0.4.0: Semantic HTML Structure ── -->
        <header class="header">
            <div class="header-left">
                <h1>🤖 Gruper: The Multi-Agent Conversation System</h1>
                <p>v0.4.5
                    <!-- v0.2.0: Security Shield icon with tooltip -->
                    <span class="tooltip-wrapper" style="margin-left: 8px;">
                        <span style="font-size: 1.1em; cursor: help;" aria-label="Security features">🛡️</span>
                        <span class="tooltip">Streamlined UX</span>
                    </span>
                </p>
            </div>
            <div class="header-right">
                <div class="tooltip-wrapper">
                    <button class="btn btn-sm btn-info" onclick="showHelp()" aria-label="Help and shortcuts">❓</button>
                    <span class="tooltip">Help & Shortcuts</span>
                </div>
                <div class="tooltip-wrapper">
                    <button class="btn btn-sm btn-info" onclick="openModal('analyticsModal')" aria-label="Analytics dashboard">📊</button>
                    <span class="tooltip">Analytics (A)</span>
                </div>
                <div class="tooltip-wrapper">
                    <button class="btn btn-sm btn-secondary" onclick="toggleDebugLog()" id="debugToggleBtn" aria-label="Toggle debug log">🐛</button>
                    <span class="tooltip">Debug Log (L)</span>
                </div>
                <label class="checkbox-group">
                    <input type="checkbox" id="darkModeToggle" class="checkbox-input" aria-label="Dark mode">
                    <span>🌙 Dark (D)</span>
                </label>
                <!-- v0.4.1: Text Size Control -->
                <div class="tooltip-wrapper">
                    <select id="textSizeControl" class="form-input" style="padding: 8px 12px; font-size: 0.9em; border-radius: 10px;" onchange="setFontScale(parseFloat(this.value))" aria-label="Text size">
                        <option value="0.8">Text 80%</option>
                        <option value="0.9">Text 90%</option>
                        <option value="1.0" selected>Text 100%</option>
                        <option value="1.1">Text 110%</option>
                        <option value="1.2">Text 120%</option>
                        <option value="1.3">Text 130%</option>
                        <option value="1.4">Text 140%</option>
                    </select>
                    <span class="tooltip">Adjust text size for accessibility</span>
                </div>
            </div>
        </header>

        <main class="main-content" role="main">
            <aside class="sidebar" id="sidebar" role="complementary" aria-label="Agent configuration and settings">
                <button class="sidebar-toggle"
                        onclick="toggleSidebar()"
                        aria-label="Toggle sidebar visibility"
                        aria-expanded="true"
                        aria-controls="sidebar"
                        title="Toggle Sidebar (S)">
                    <span class="sidebar-toggle-icon" aria-hidden="true">◀</span>
                </button>
                
                <div class="sidebar-content">
                    <div class="sidebar-section">
                        <div class="section-header" onclick="toggleSection(this)">
                            <span>🔌 Connection</span>
                            <span class="collapse-icon">▼</span>
                        </div>
                        <div class="section-content">
                            <div class="form-group">
                                <label class="form-label">Quick Presets</label>
                                <div class="flex gap-1" style="margin-bottom: 8px;">
                                    <button class="btn btn-xs btn-secondary" onclick="setIPPreset('ollama')" style="flex: 1; font-size: 0.8em; padding: 6px 8px;">
                                        Ollama
                                    </button>
                                    <button class="btn btn-xs btn-secondary" onclick="setIPPreset('localai')" style="flex: 1; font-size: 0.8em; padding: 6px 8px;">
                                        LocalAI
                                    </button>
                                    <button class="btn btn-xs btn-secondary" onclick="setIPPreset('custom')" style="flex: 1; font-size: 0.8em; padding: 6px 8px;">
                                        Custom
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label" for="ollamaUrl">Server URL
                                    <span class="tooltip-icon" title="API endpoint for Ollama (default: :11434) or LocalAI (default: :8080)">ⓘ</span>
                                </label>
                                <input type="text" id="ollamaUrl" class="form-input" value="http://localhost:11434" placeholder="http://localhost:11434" onchange="handleOllamaUrlChange()">
                            </div>

                            <!-- v0.4.1: Global Timeout Control -->
                            <div class="form-group">
                                <label class="form-label">Max Timeout (seconds)
                                    <span class="tooltip-icon" title="Increase for slow models or laptop hardware; per-agent settings override global.">ⓘ</span>
                                </label>
                                <select id="globalTimeout" class="form-input" onchange="handleGlobalTimeoutChange()">
                                    <option value="180000">Fast (180s / 3 min)</option>
                                    <option value="300000" selected>Balanced (300s / 5 min)</option>
                                    <option value="600000">Patient (600s / 10 min)</option>
                                    <option value="900000">Very Patient (900s / 15 min)</option>
                                    <option value="custom">Custom...</option>
                                </select>
                                <input type="number" id="customGlobalTimeout" class="form-input" style="display:none; margin-top:8px;" min="60" max="3600" placeholder="Seconds (60-3600)" onchange="handleCustomGlobalTimeoutChange()">
                            </div>

                            <div class="form-group" id="connectionStatus">
                                <label class="form-label">Status</label>
                                <div class="flex items-center gap-1">
                                    <span class="status-dot" id="connectionDot" style="width: 12px; height: 12px;"></span>
                                    <span class="status-text" id="connectionText" style="font-weight: 600;">Checking...</span>
                                </div>
                                <div class="connection-details text-muted" id="connectionDetails" style="display: none; font-size: 0.85em; margin-top: 5px;">
                                    Models: <span id="modelCount">0</span> | Latency: <span id="latency">--</span>ms
                                </div>
                            </div>
                            
                            <div class="flex gap-1">
                                <button class="btn btn-primary flex-1" id="testConnectionBtn" onclick="testConnection()">
                                    🔄 Test Connection
                                </button>
                                <div class="tooltip-wrapper">
                                    <button class="btn btn-secondary" id="autoReconnectBtn" onclick="toggleAutoReconnect()" title="Toggle Auto-reconnect" style="padding: 10px 14px;">
                                        🔁
                                    </button>
                                    <span class="tooltip">Auto-Reconnect</span>
                                </div>
                            </div>
                            <div id="statusMessage" class="mt-1 text-muted text-center" style="font-size: 0.85em;"></div>
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <div class="section-header" onclick="toggleSection(this)">
                            <span>🤖 Agents (6 Available)</span>
                            <span class="collapse-icon">▼</span>
                        </div>
                        <div class="section-content">
                            <div id="agentConfigContainer">
                                </div>
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <div class="section-header" onclick="toggleSection(this)">
                            <span>🧠 Memory</span>
                            <span class="collapse-icon">▼</span>
                        </div>
                        <div class="section-content">
                            <label class="checkbox-group mb-2">
                                <input type="checkbox" id="enableMemory" class="checkbox-input" checked>
                                <span>Enable Memory
                                    <span class="tooltip-icon" title="When enabled, agents remember previous rounds of conversation for context">ⓘ</span>
                                </span>
                            </label>
                            <div class="form-group">
                                <label class="form-label" for="memoryDepth">Memory Depth (rounds)
                                    <span class="tooltip-icon" title="Number of previous conversation rounds each agent can remember (1-20)">ⓘ</span>
                                </label>
                                <input type="number" id="memoryDepth" class="form-input" value="5" min="1" max="20">
                            </div>
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <div class="section-header" onclick="toggleSection(this)">
                            <span>📊 Analysis & Rounds</span>
                            <span class="collapse-icon">▼</span>
                        </div>
                        <div class="section-content">
                            <label class="checkbox-group mb-2">
                                <input type="checkbox" id="enableHumanInLoop" class="checkbox-input" aria-describedby="humanInLoopTooltip">
                                <span>Enable Human-in-the-Loop
                                    <span class="tooltip-icon" id="humanInLoopTooltip" title="When enabled, the conversation will automatically pause after each round, allowing you to review before continuing. You become an active participant, not a passive spectator.">ⓘ</span>
                                </span>
                            </label>

                            <label class="checkbox-group mb-2">
                                <input type="checkbox" id="enableConsensus" class="checkbox-input" aria-describedby="consensusTooltip">
                                <span>Enable Consensus Detection
                                    <span class="tooltip-icon" id="consensusTooltip" title="When enabled, the conversation will automatically stop when agents reach consensus (based on agreement threshold). Useful for finding common ground.">ⓘ</span>
                                </span>
                            </label>

                            <div class="form-group">
                                <label class="form-label" for="maxRounds">Max Rounds
                                    <span class="tooltip-icon" title="Maximum number of conversation rounds before stopping (1-50). The conversation runs until this limit or you stop it—no premature halts for fake consensus.">ⓘ</span>
                                </label>
                                <input type="number" id="maxRounds" class="form-input" value="10" min="1" max="50">
                            </div>
							<div class="sidebar-section">
                        <div class="section-header" onclick="toggleSection(this)">
                            <span>⚡ Quick Actions</span>
                             <span class="collapse-icon">▼</span>
                         </div>
                        <div class="section-content">
                            <div class="flex flex-col gap-1">
                                <button class="btn btn-sm btn-secondary" onclick="exportConfiguration()">
                                    💾 Export Config
                                    <span class="tooltip-icon" title="Download current agent/memory/consensus settings as JSON file">ⓘ</span>
                                </button>
                                <button class="btn btn-sm btn-secondary" onclick="importConfiguration()">
                                    📂 Import Config
                                    <span class="tooltip-icon" title="Load agent/memory/consensus settings from a JSON file">ⓘ</span>
                                </button>
                                <button class="btn btn-sm btn-secondary" onclick="savePreset()">
                                    ⭐ Save Preset
                                    <span class="tooltip-icon" title="Save current settings as a named preset in local storage">ⓘ</span>
                                </button>
                                <button class="btn btn-sm btn-secondary" onclick="loadPreset()">
                                    📋 Load Preset
                                    <span class="tooltip-icon" title="Load a previously saved preset from local storage">ⓘ</span>
                                </button>
                            </div>
                        </div>
                    </div>
                        </div>
                    </div>

                    <!-- Powered by Ollama footer badge -->
                    <div style="margin-top: 24px; padding: 16px; text-align: center; border-top: 1px solid var(--border-color);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px;">
                            Gruper powered by
                        </div>
                        <div style="font-size: 1.1em; font-weight: 700; background: linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                            🦙 Ollama
                        </div>
                       <div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 4px;">
                            v0.4.5 - Streamlined UX
                        </div>
                    </div>
                </div>
            </aside>

            <div class="conversation-area">
                <div class="tabs-container" id="tabsContainer">
                    <div class="tab active" data-conversation-id="1" onclick="switchConversation(1)">
                        <span>💬 Conversation 1</span>
                        <span class="tab-close" onclick="closeConversation(1, event)" aria-label="Close conversation tab" role="button" tabindex="0">×</span>
                    </div>
                    <button class="new-tab-btn" onclick="newConversation()">+ New (N)</button>
                </div>

                <div class="status-bar">
                    <div class="status-indicator">
                        <div class="status-dot" id="statusDot"></div>
                        <span id="statusText" aria-live="polite" role="status">Not Connected</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span id="roundCounter">Round: 0</span>
                        <div class="health-indicator hidden" id="healthIndicator"></div>
                        <button class="btn btn-xs btn-secondary hidden" id="circuitBreakerResetBtn" onclick="resetCircuitBreaker()" title="Reset Circuit Breaker">
                            🔄 Reset CB
                        </button>
                    </div>
                </div>

                <div class="progress-container hidden" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-label">
                        <span id="progressLabel">Processing...</span>
                        <span id="progressPercent">0%</span>
                    </div>
                </div>
                
                <div class="search-bar hidden" id="searchBar">
                    <div class="search-input-wrapper">
                        <span class="search-icon">🔍</span>
                        <input type="text" id="searchInput" placeholder="Search messages... (Press / to focus)" onkeyup="searchMessages(this.value)">
                        <button class="search-clear" id="searchClear" onclick="clearSearch()" aria-label="Clear search">×</button>
                    </div>
                </div>

                <div class="messages-container" id="messagesContainer" role="log" aria-live="polite" aria-label="Conversation messages">
                    <div style="text-align: center; padding: 60px 20px; color: var(--text-secondary);">
                        <div class="ai-orb" style="margin-bottom: 24px;">
                            <svg width="120" height="120" viewBox="0 0 120 120">
                                <defs>
                                    <linearGradient id="orbGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" stop-color="#6366f1"/>
                                        <stop offset="50%" stop-color="#a78bfa"/>
                                        <stop offset="100%" stop-color="#ec4899"/>
                                    </linearGradient>
                                </defs>
                                <circle cx="60" cy="60" r="50" fill="url(#orbGrad)" opacity="0.8">
                                    <animate attributeName="r" values="48;52;48" dur="4s" repeatCount="indefinite"/>
                                </circle>
                                <circle cx="60" cy="60" r="30" fill="white" opacity="0.1"/>
                                <circle cx="60" cy="60" r="10" fill="white" opacity="0.4">
                                    <animate attributeName="opacity" values="0.4;1;0.4" dur="2s" repeatCount="indefinite"/>
                                </circle>
                            </svg>
                        </div>
                        <h3 style="margin-bottom: 12px; font-size: 1.5em;">Ready to Start</h3>
                        <p style="margin-bottom: 8px;">Configure your agents, enter a task, and click Start to begin the conversation.</p>
                        <p style="margin-top: 16px; font-size: 0.9em; background: var(--bg-light); padding: 12px; border-radius: var(--radius-md); display: inline-block;">
                            💡 Press <kbd style="padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid var(--border-color);">Cmd+K</kbd> or
                            <kbd style="padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid var(--border-color);">Ctrl+K</kbd> to open the command palette
                        </p>
                    </div>
                    </div>

                <button class="scroll-bottom-btn" id="scrollBottomBtn" onclick="scrollToBottom()">↓</button>

                <!-- v0.2.0: Reorganized UX - Secondary actions toolbar at top -->
                <section class="action-buttons-panel" aria-label="Secondary controls" style="justify-content: space-between; padding: 10px 20px;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div class="tooltip-wrapper">
                            <button class="btn btn-sm btn-secondary" id="resetBtn" onclick="resetConversation()" aria-label="Reset conversation">
                                🔄 Reset
                            </button>
                            <span class="tooltip">Clear all messages and start fresh (R)</span>
                        </div>
                        <div class="tooltip-wrapper">
                            <button class="btn btn-sm btn-info" id="exportBtn" onclick="exportConversation()" disabled aria-label="Export conversation">
                                💾 Export
                            </button>
                            <span class="tooltip">Download conversation as JSON (E)</span>
                        </div>
                        <div class="tooltip-wrapper">
                            <button class="btn btn-sm btn-secondary" onclick="toggleSearch()" aria-label="Toggle search">
                                🔍 Search
                            </button>
                            <span class="tooltip">Search messages (/)</span>
                        </div>
                    </div>

                    <!-- v0.2.0: Running controls (Pause/Resume/Stop) - shown when active -->
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div class="tooltip-wrapper">
                            <button class="btn btn-warning hidden" id="pauseBtn" onclick="pauseConversation()" aria-label="Pause conversation">
                                ⏸️ Pause
                            </button>
                            <span class="tooltip">Pause after current agent (P)</span>
                        </div>
                        <div class="tooltip-wrapper">
                            <button class="btn btn-info hidden" id="resumeBtn" onclick="resumeConversation()" aria-label="Resume conversation">
                                ▶️ Continue
                            </button>
                            <span class="tooltip">Resume conversation (Space)</span>
                        </div>
                        <div class="tooltip-wrapper">
                            <button class="btn btn-danger hidden" id="stopBtn" onclick="stopConversation()" aria-label="Stop conversation">
                                ⏹️ Stop
                            </button>
                            <span class="tooltip">Stop immediately (Ctrl/Cmd+S)</span>
                        </div>
                    </div>
                </section>

                <!-- v0.3.0: Input area with Start button and minimize control -->
                <section class="control-panel" id="promptPanel" aria-label="Task input" style="position: relative; padding: 20px; display: block; transition: max-height 0.3s ease, opacity 0.3s ease;">
                    <!-- v0.3.0: Minimize button -->
                    <button class="minimize-prompt-btn" onclick="togglePromptPanel()" id="minimizePromptBtn" title="Minimize/Maximize prompt panel">
                        ▼
                    </button>

                    <textarea
                        id="taskInput"
                        class="task-input"
                        rows="8"
                        placeholder="Enter your task or question here for the agents to discuss...

Example: Analyze the pros and cons of remote work for tech companies.
Example: What are the ethical considerations of AI in healthcare?"
                        onkeypress="handleTaskInputKeypress(event)"
                        oninput="validateTaskInput()"
                        aria-label="Task input for agent discussion"
                        style="width: 100%; min-height: 150px; max-height: 400px; resize: vertical; font-size: 14px; line-height: 1.6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif; padding-bottom: 60px;"
                    ></textarea>

                    <!-- v0.2.0: Primary Start button - bottom-right like Gmail/Slack -->
                    <div style="position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; align-items: center;">
                        <div class="tooltip-wrapper">
                            <button class="btn btn-success" id="startBtn" onclick="startConversation()" disabled aria-label="Start conversation" style="font-size: 1.05em; padding: 12px 28px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                                ▶️ Start Discussion
                            </button>
                            <span class="tooltip">Begin multi-agent conversation (Space)</span>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- v0.3.0: Custom glass confirmation modal -->
    <div class="confirm-modal-overlay" id="confirmModal">
        <div class="confirm-modal">
            <div class="confirm-modal-icon" id="confirmModalIcon">⚠️</div>
            <div class="confirm-modal-title" id="confirmModalTitle">Confirm Action</div>
            <div class="confirm-modal-message" id="confirmModalMessage">Are you sure?</div>
            <div class="confirm-modal-actions">
                <button class="btn btn-secondary" onclick="closeConfirmModal(false)">Cancel</button>
                <button class="btn btn-danger" id="confirmModalConfirmBtn" onclick="closeConfirmModal(true)">Confirm</button>
            </div>
        </div>
    </div>

    <div class="debug-log-panel" id="debugLogPanel">
        <div class="debug-log-header">
            <div class="debug-log-title">🐛 Debug Log</div>
            <div class="debug-log-controls">
                <button onclick="toggleDebugLogExpand()">↕️ Expand</button>
                <button onclick="copyDebugLog()">Copy</button>
                <button onclick="clearDebugLog()">Clear</button>
                <button onclick="exportDebugLog()">Export</button>
                <button onclick="toggleDebugLog()">Close (L)</button>
            </div>
        </div>
        <!-- v0.4.2: Debug filter controls -->
        <div class="debug-controls">
            <input type="text" id="debugSearch" placeholder="Filter logs..." />
            <label><input type="checkbox" id="debugAutoScroll" checked /> Auto-scroll</label>
        </div>
        <div id="debugLogContent"></div>
    </div>

    <!-- v0.4.2: Version badge -->
    <div class="version-badge">Gruper v0.4.5</div>
    <script>
        /* =================================================================
           CORE SYSTEM - v0.2.0 Refactored with State Closure
           ================================================================= */

        // v0.4.5: Application version updated
        const APP_VERSION = '0.4.5 - Streamlined UX';
        const STORAGE_KEY = 'multiAgentApp';
        
        /* =================================================================
           LOGGING SYSTEM - (Merged from v24-3 and v0-1-2)
           ================================================================= */
        
        const LogLevel = {
            DEBUG: 0,
            INFO: 1,
            WARNING: 2,
            ERROR: 3,
            SUCCESS: 4
        };
        
        const currentLogLevel = LogLevel.DEBUG;
        const debugEntries = [];
        const MAX_DEBUG_ENTRIES = 200;
        let isDebugPanelVisible = false;
        
        /**
         * Central logging function
         */
        function log(level, message, data = null) {
            if (level < currentLogLevel) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const levelName = Object.keys(LogLevel).find(key => LogLevel[key] === level).toLowerCase();
            
            // Console output
            const consoleMsg = `[${timestamp}] [${levelName.toUpperCase()}] ${message}`;
            if (data) {
                console.log(consoleMsg, data);
            } else {
                console.log(consoleMsg);
            }
            
            // Debug log UI
            const entry = {
                timestamp,
                level: levelName,
                message,
                data
            };
            
            debugEntries.push(entry);
            if (debugEntries.length > MAX_DEBUG_ENTRIES) {
                debugEntries.shift();
            }
            
            if (isDebugPanelVisible) {
                renderDebugLogEntry(entry);
            }
        }
        
        // Convenience logging functions
        const logDebug = (msg, data) => log(LogLevel.DEBUG, msg, data);
        const logInfo = (msg, data) => log(LogLevel.INFO, msg, data);
        const logWarning = (msg, data) => log(LogLevel.WARNING, msg, data);
        const logError = (msg, data) => log(LogLevel.ERROR, msg, data);
        const logSuccess = (msg, data) => log(LogLevel.SUCCESS, msg, data);
        
        /**
         * Toggle v0-1-2 style debug log
         */
        function toggleDebugLog() {
            isDebugPanelVisible = !isDebugPanelVisible;
            const panel = document.getElementById('debugLogPanel');
            const btn = document.getElementById('debugToggleBtn');
            
            if (isDebugPanelVisible) {
                panel.classList.add('active');
                btn.style.background = 'var(--success-color)';
                renderDebugLog(); // Full render
                logInfo('Debug log enabled');
            } else {
                panel.classList.remove('active');
                btn.style.background = '';
            }
        }

        /**
         * Full render of v0-1-2 debug log
         * v0.4.2: With search filter support
         */
        function renderDebugLog() {
            const content = document.getElementById('debugLogContent');
            const searchTerm = (document.getElementById('debugSearch')?.value || '').toLowerCase();

            // v0.4.2: Filter entries based on search
            let filteredEntries = debugEntries;
            if (searchTerm) {
                filteredEntries = debugEntries.filter(entry => {
                    const entryText = `${entry.timestamp} ${entry.level} ${entry.message}`.toLowerCase();
                    return entryText.includes(searchTerm);
                });
            }

            content.innerHTML = filteredEntries.map(entry =>
                getDebugLogEntryHTML(entry)
            ).join('');

            // v0.4.2: Auto-scroll only if checkbox is checked
            const autoScroll = document.getElementById('debugAutoScroll');
            if (autoScroll && autoScroll.checked) {
                content.scrollTop = content.scrollHeight;
            }
        }

        /**
         * Append a single entry to v0-1-2 debug log
         */
        function renderDebugLogEntry(entry) {
            const content = document.getElementById('debugLogContent');
            if (!content) return;

            // v0.4.2: Check if entry matches current search filter
            const searchTerm = (document.getElementById('debugSearch')?.value || '').toLowerCase();
            if (searchTerm) {
                const entryText = `${entry.timestamp} ${entry.level} ${entry.message}`.toLowerCase();
                if (!entryText.includes(searchTerm)) {
                    return; // Skip filtered entries
                }
            }

            content.innerHTML += getDebugLogEntryHTML(entry);

            // v0.4.2: Auto-scroll only if checkbox is checked
            const autoScroll = document.getElementById('debugAutoScroll');
            if (autoScroll && autoScroll.checked) {
                content.scrollTop = content.scrollHeight;
            }
        }
        
        function getDebugLogEntryHTML(entry) {
            // Sanitize message
            const safeMessage = entry.message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            
            // Sanitize and format data
            let dataHtml = '';
            if (entry.data) {
                try {
                    const dataString = JSON.stringify(entry.data, null, 2);
                    const safeData = dataString.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    dataHtml = `<div class="debug-data">${safeData}</div>`;
                } catch (e) {
                    dataHtml = `<div class="debug-data">[Could not stringify data]</div>`;
                }
            }

            return `
                <div class="debug-entry">
                    <span class="debug-timestamp">${entry.timestamp}</span>
                    <span class="debug-level ${entry.level}">${entry.level.toUpperCase()}</span>
                    <span class="debug-message">${safeMessage}</span>
                    ${dataHtml}
                </div>
            `;
        }


        /**
         * Clear debug log
         */
        function clearDebugLog() {
            debugEntries.length = 0;
            const content = document.getElementById('debugLogContent');
            if(content) content.innerHTML = '';
            logInfo('Debug log cleared');
        }

        /**
         * Copy debug log (v0-1-2)
         */
        function copyDebugLog() {
            const logText = debugEntries.map(entry => {
                let line = `${entry.timestamp} ${entry.level.toUpperCase()} ${entry.message}`;
                if (entry.data) {
                    line += '\n' + JSON.stringify(entry.data, null, 2);
                }
                return line;
            }).join('\n');
            
            navigator.clipboard.writeText(logText).then(() => {
                showToast('Debug log copied to clipboard!', {
                    type: 'success',
                    title: 'Copied',
                    duration: 2000
                });
                logSuccess('Debug log copied to clipboard');
            }).catch(err => {
                showToast('Failed to copy: ' + err.message, {
                    type: 'error',
                    title: 'Copy Failed',
                    duration: 3000
                });
            });
        }

        /**
         * Export debug log (v0-1-2)
         */
        function exportDebugLog() {
            const data = {
                version: APP_VERSION,
                timestamp: new Date().toISOString(),
                entries: debugEntries
            };
            downloadJSON(data, `debug_log_${Date.now()}.json`);
            logSuccess('Debug log exported');
        }
        
        
        /* =================================================================
           API COMMUNICATION LAYER - (from v24-3)
           ================================================================= */
        
        class ApiClient {
            constructor(baseUrl) {
                this.baseUrl = baseUrl;
                this.activeRequests = new Map();
                this.connectionState = 'disconnected';
                this.lastSuccessfulPing = null;
                this.retryConfig = {
                    maxAttempts: 3,
                    baseDelay: 1000,
                    maxDelay: 10000,
                    multiplier: 2
                };
            }
            
            getRetryDelay(attempt) {
                const delay = Math.min(
                    this.retryConfig.baseDelay * Math.pow(this.retryConfig.multiplier, attempt - 1),
                    this.retryConfig.maxDelay
                );
                return delay + Math.random() * 1000;
            }
            
            async request(endpoint, options = {}, retryCount = 0) {
                const requestId = `${endpoint}-${Date.now()}`;
                const controller = new AbortController();
                
                this.activeRequests.set(requestId, controller);
                
                try {
                    // v0-1-2 style request timeout logic
                    const timeout = options.timeout || 30000; 
                    const timeoutId = setTimeout(() => {
                        logWarning(`Request timed out after ${timeout / 1000}s`, { endpoint });
                        controller.abort();
                    }, timeout);
                    
                    const response = await fetch(`${this.baseUrl}${endpoint}`, {
                        ...options,
                        signal: controller.signal,
                        headers: {
                            'Content-Type': 'application/json',
                            ...options.headers
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    this.activeRequests.delete(requestId);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        logError(`API Error ${response.status}`, { endpoint, errorText });
                        throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                    }
                    
                    // Handle empty (204 No Content) responses
                    if (response.status === 204) {
                        return null;
                    }

                    const responseText = await response.text();
                    
                    // Safe JSON parsing (v24-3)
                    try {
                        return JSON.parse(responseText);
                    } catch (jsonError) {
                        logError('Failed to parse JSON response', { endpoint, responseText });
                        throw new Error('Invalid JSON response from server');
                    }
                    
                } catch (error) {
                    this.activeRequests.delete(requestId);
                    
                    if (error.name === 'AbortError') {
                        // Don't retry user-cancelled requests
                        if (options.signal && options.signal.aborted) {
                             throw new Error('Request cancelled by user');
                        }
                        // This is a timeout
                        throw new Error(`Request timed out for ${endpoint}`);
                    }
                    
                    // Retry logic for network errors
                    if (retryCount < this.retryConfig.maxAttempts - 1) {
                        const delay = this.getRetryDelay(retryCount + 1);
                        logWarning(`Retry attempt ${retryCount + 1}/${this.retryConfig.maxAttempts} after ${delay}ms`, {
                            endpoint,
                            error: error.message
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return this.request(endpoint, options, retryCount + 1);
                    }
                    
                    logError(`API request failed after retries`, { endpoint, error: error.message });
                    throw error;
                }
            }
            
            cancelAll() {
                for (const [id, controller] of this.activeRequests.entries()) {
                    controller.abort();
                    this.activeRequests.delete(id);
                }
                logInfo('All active requests cancelled');
            }
            
            async testConnection() {
                const startTime = Date.now();
                const endpoints = ['/api/tags', '/api/models', '/api/version'];
                
                for (const endpoint of endpoints) {
                    try {
                        logDebug(`Testing endpoint: ${endpoint}`);
                        const response = await this.request(endpoint, {
                            method: 'GET',
                            timeout: 5000
                        });
                        
                        const latency = Date.now() - startTime;
                        this.lastSuccessfulPing = Date.now();
                        this.connectionState = 'connected';
                        
                        logSuccess(`Connected via ${endpoint}`, { latency: `${latency}ms` });
                        
                        let models = [];
                        if (response?.models) {
                            // Ollama format { name: "model:tag", ... }
                            models = response.models.map(m => m.name || m);
                        } else if (response?.data && Array.isArray(response.data)) {
                             // Other potential formats
                            models = response.data.map(m => m.name || m);
                        } else {
                            logWarning("Could not parse models from response", { endpoint, response });
                        }
                        
                        return { success: true, endpoint, models, latency };
                        
                    } catch (error) {
                        logDebug(`Endpoint ${endpoint} failed: ${error.message}`);
                        continue;
                    }
                }
                
                this.connectionState = 'disconnected';
                throw new Error('No compatible endpoint found');
            }
            
            async chat(model, messages, options = {}) {
                // Merge v0-1-2 advanced options with v24-3 logic
                const apiOptions = {
                    temperature: options.temperature ?? 0.7,
                    top_p: options.topP ?? 0.9,
                    top_k: options.topK ?? 40,
                    repeat_penalty: options.repeatPenalty ?? 1.1,
                    num_predict: options.maxTokens ?? 2048,
                    // num_ctx: options.contextLength ?? 4096 // Pass context length if API supports it
                };
                
                if (options.seed) apiOptions.seed = options.seed;
                if (options.stopSequences && options.stopSequences.length > 0) {
                    apiOptions.stop = options.stopSequences;
                }
                
                return this.request('/api/chat', {
                    method: 'POST',
                    timeout: options.timeout || 300000,
                    body: JSON.stringify({
                        model,
                        messages,
                        stream: false,
                        options: apiOptions
                    })
                });
            }
        }
        
        /* =================================================================
           STATE MANAGEMENT - (Merged)
           ================================================================= */
        
        const state = {
            // Connection
            apiClient: null,
            connected: false,
            ollamaUrl: 'http://localhost:11434',
            availableModels: [],
            connectionHealth: 'unknown',
            autoReconnect: true,
            reconnectInterval: null,
            healthCheckInterval: null,
            lastHealthCheck: null,
            // v0.4.1: Timeout configuration
            connection: {
                timeout: { global: 300000 } // Default: 5 minutes (300s = 300000ms)
            },
            
            // Conversations
            conversations: {},
            activeConversationId: 1,
            nextConversationId: 2,
            
            // 6 Agents configuration (from v24-3, with v0-1-2 params)
            // v0.2.0: Added failureCount and disabledByCircuitBreaker for resilience
            agents: {
                1: {
                    enabled: true,
                    model: '',
                    config: {
                        personality: 'Analytical and data-driven',
                        temperature: 0.7, topP: 0.9, topK: 40, repeatPenalty: 1.1, maxTokens: 2048,
                        contextLength: 4096, seed: null, stopSequences: [],
                        timeout: null // v0.4.1: Per-agent timeout override (null = use global)
                    },
                    failureCount: 0, // v0.2.0: Circuit breaker failure tracking
                    disabledByCircuitBreaker: false // v0.2.0: Auto-disabled flag
                },
                2: {
                    enabled: true,
                    model: '',
                    config: {
                        personality: 'Creative and innovative',
                        temperature: 0.8, topP: 0.95, topK: 50, repeatPenalty: 1.0, maxTokens: 2048,
                        contextLength: 4096, seed: null, stopSequences: [],
                        timeout: null // v0.4.1: Per-agent timeout
                    },
                    failureCount: 0, // v0.2.0: Circuit breaker
                    disabledByCircuitBreaker: false
                },
                3: {
                    enabled: true,
                    model: '',
                    config: {
                        personality: 'Critical and thorough',
                        temperature: 0.6, topP: 0.85, topK: 30, repeatPenalty: 1.2, maxTokens: 2048,
                        contextLength: 4096, seed: null, stopSequences: [],
                        timeout: null // v0.4.1: Per-agent timeout
                    },
                    failureCount: 0, // v0.2.0: Circuit breaker
                    disabledByCircuitBreaker: false
                },
                4: {
                    enabled: false,
                    model: '',
                    config: {
                        personality: 'Strategic and forward-thinking',
                        temperature: 0.7, topP: 0.9, topK: 40, repeatPenalty: 1.1, maxTokens: 2048,
                        contextLength: 4096, seed: null, stopSequences: [],
                        timeout: null // v0.4.1: Per-agent timeout
                    },
                    failureCount: 0, // v0.2.0: Circuit breaker
                    disabledByCircuitBreaker: false
                },
                5: {
                    enabled: false,
                    model: '',
                    config: {
                        personality: 'Empathetic and user-focused',
                        temperature: 0.75, topP: 0.92, topK: 45, repeatPenalty: 1.05, maxTokens: 2048,
                        contextLength: 4096, seed: null, stopSequences: [],
                        timeout: null // v0.4.1: Per-agent timeout
                    },
                    failureCount: 0, // v0.2.0: Circuit breaker
                    disabledByCircuitBreaker: false
                },
                6: {
                    enabled: false,
                    model: '',
                    config: {
                        personality: 'Technical and precise',
                        temperature: 0.5, topP: 0.8, topK: 25, repeatPenalty: 1.3, maxTokens: 2048,
                        contextLength: 4096, seed: null, stopSequences: [],
                        timeout: null // v0.4.1: Per-agent timeout
                    },
                    failureCount: 0, // v0.2.0: Circuit breaker
                    disabledByCircuitBreaker: false
                }
            },
            
            // Conversation state
            running: false,
            paused: false,
            currentRound: 0,
            
            // Memory
            memory: {
                enabled: true,
                depth: 5,
                history: []
            },
            
            // Analysis & Human-in-the-Loop (v0.3.0 - disabled by default)
            analysis: {
                humanInLoop: false // Auto-pause after each round for user review
            },

            // Consensus (v0.3.0 - re-added, disabled by default)
            consensus: {
                enabled: false,
                threshold: 0.7 // Agreement threshold (0-1)
            },
            
            // Analytics
            analytics: {
                totalRounds: 0,
                totalMessages: 0,
                responseTimes: [],
                successCount: 0,
                failureCount: 0
            },
            
            // v0-1-2 UI State
            sidebarCollapsed: false,
            advancedPanelsExpanded: {},
            // v0.4.1: UI configuration
            ui: {
                fontScale: 1.0, // Text scale multiplier (0.8 to 1.4)
                debugLogHeight: 300 // Resizable debug log height in pixels
            },

            // v0.2.0: Chart lifecycle management to prevent memory leaks
            charts: {}, // Stores Chart.js instances by ID for proper cleanup

            // v0.4.1: Consensus tracking
            consensusReached: false
        };

        // v0-1-2 Agent Templates (with new additions)
        const agentTemplates = {
            analyst: {
                personality: 'You are a data-driven analyst. Approach problems methodically, cite evidence, and provide logical reasoning. Focus on facts and quantifiable insights. Be precise and thorough in your analysis.',
                temperature: 0.3, topP: 0.9, topK: 40, repeatPenalty: 1.1
            },
            creative: {
                personality: 'You are a creative thinker. Generate innovative ideas, explore unconventional solutions, and think outside the box. Embrace bold and imaginative approaches. Be willing to take risks and suggest novel perspectives.',
                temperature: 0.9, topP: 0.95, topK: 50, repeatPenalty: 1.0
            },
            critic: {
                personality: 'You are a critical thinker. Question assumptions, identify potential flaws, and provide constructive criticism. Be thorough and skeptical. Look for edge cases, vulnerabilities, and areas of improvement.',
                temperature: 0.4, topP: 0.85, topK: 40, repeatPenalty: 1.2
            },
            synthesizer: {
                personality: 'You are a synthesizer. Find common ground, integrate different perspectives, and build consensus. Be diplomatic and balanced. Look for ways to combine the best ideas from all viewpoints.',
                temperature: 0.6, topP: 0.9, topK: 45, repeatPenalty: 1.1
            },
            expert: {
                personality: 'You are a domain expert. Provide authoritative, precise information. Be knowledgeable and confident in your expertise. Cite specific details, best practices, and established principles.',
                temperature: 0.2, topP: 0.85, topK: 35, repeatPenalty: 1.1
            },
            devil: {
                personality: "You are a devil's advocate. Challenge the prevailing view, present alternative perspectives, and provoke deeper thinking through contrarian positions. Be intellectually provocative while remaining constructive.",
                temperature: 0.7, topP: 0.9, topK: 45, repeatPenalty: 1.0
            },
            // --- NEW TEMPLATES ---
            philosopher: {
                personality: "You are a philosopher. Explore the 'why' behind the 'what'. Use logical reasoning, examine ethical implications, and question foundational assumptions. Focus on principles and abstract concepts.",
                temperature: 0.8, topP: 0.9, topK: 50, repeatPenalty: 1.05
            },
            economist: {
                personality: "You are an economist. Analyze the situation through the lens of incentives, scarcity, cost-benefit, and market impacts. Provide data-driven insights on socioeconomic consequences.",
                temperature: 0.3, topP: 0.85, topK: 30, repeatPenalty: 1.1
            },
            ethicist: {
                personality: "You are an ethicist. Evaluate the moral dimensions of the topic. Discuss fairness, rights, duties, and potential harms to different stakeholders. Argue from established ethical frameworks.",
                temperature: 0.6, topP: 0.9, topK: 40, repeatPenalty: 1.0
            },
            // ── v0.4.0: NEW AGENT TEMPLATES ──
            scientist: {
                personality: "You are a scientist. Base your arguments on empirical evidence, hypothesis testing, and the scientific method. Prioritize falsifiability, reproducibility, and data-backed conclusions. Question unproven claims rigorously.",
                temperature: 0.4, topP: 0.85, topK: 40, repeatPenalty: 1.1
            },
            psychologist: {
                personality: "You are a psychologist. Analyze human behavior, motivations, cognitive biases, and emotional factors. Draw on psychological theories to explain individual and group dynamics.",
                temperature: 0.7, topP: 0.9, topK: 45, repeatPenalty: 1.05
            },
            engineer: {
                personality: "You are an engineer. Focus on practical implementation, technical feasibility, design optimization, and problem-solving. Consider constraints like resources, scalability, and efficiency.",
                temperature: 0.5, topP: 0.9, topK: 40, repeatPenalty: 1.1
            }
        };

        // v0-1-2 Command Palette
        const commands = [
            { id: 'start', icon: '▶️', title: 'Start Conversation', description: 'Begin the multi-agent conversation', action: () => document.getElementById('startBtn').click(), shortcut: 'Space' },
            { id: 'pause', icon: '⏸️', title: 'Pause Conversation', description: 'Pause the ongoing conversation', action: () => document.getElementById('pauseBtn').click(), shortcut: 'P' },
            { id: 'stop', icon: '⏹️', title: 'Stop Conversation', description: 'Stop the conversation', action: () => document.getElementById('stopBtn').click(), shortcut: 'Ctrl+S' },
            { id: 'reset', icon: '🔄', title: 'Reset Conversation', description: 'Clear and restart', action: () => document.getElementById('resetBtn').click(), shortcut: 'R' },
            { id: 'export', icon: '💾', title: 'Export Conversation', description: 'Download conversation as JSON', action: () => document.getElementById('exportBtn').click(), shortcut: 'E' },
            { id: 'analytics', icon: '📊', title: 'View Analytics', description: 'Open analytics dashboard', action: () => openModal('analyticsModal'), shortcut: 'A' },
            { id: 'debug', icon: '🐛', title: 'Toggle Debug Log', description: 'Show/hide debugging information', action: () => toggleDebugLog(), shortcut: 'L' },
            { id: 'search', icon: '🔍', title: 'Search Messages', description: 'Toggle message search', action: () => toggleSearch(), shortcut: '/' },
            { id: 'newTab', icon: '➕', title: 'New Conversation', description: 'Create a new conversation tab', action: () => newConversation(), shortcut: 'N' },
            { id: 'darkMode', icon: '🌙', title: 'Toggle Dark Mode', description: 'Switch between light and dark theme', action: () => toggleDarkMode(true), shortcut: 'D' },
            { id: 'sidebar', icon: '◀', title: 'Toggle Sidebar', description: 'Collapse or expand the sidebar', action: () => toggleSidebar(), shortcut: 'S' }
        ];
        
        /**
         * Save state (v24-3 version)
         */
        function saveState() {
            try {
                const stateToSave = {
                    ollamaUrl: state.ollamaUrl,
                    agents: state.agents,
                    memory: state.memory,
                    consensus: state.consensus,
                    autoReconnect: state.autoReconnect,
                    sidebarCollapsed: state.sidebarCollapsed, // v0-1-2
                    advancedPanelsExpanded: state.advancedPanelsExpanded, // v0-1-2
                    connection: state.connection, // v0.4.1: Timeout config
                    ui: state.ui // v0.4.1: UI state (font scale, debug height)
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                logDebug('State saved to localStorage');
            } catch (error) {
                logError('Failed to save state', error);
            }
        }
        
        /**
         * Load state (v24-3 version, merged)
         */
        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    
                    if (parsed.ollamaUrl) state.ollamaUrl = parsed.ollamaUrl;
                    if (parsed.agents) {
                        Object.keys(parsed.agents).forEach(id => {
                            if (state.agents[id]) {
                                // Deep merge config
                                state.agents[id] = {
                                     ...state.agents[id],
                                     ...parsed.agents[id],
                                     config: {
                                        ...state.agents[id].config,
                                        ...(parsed.agents[id].config || {})
                                     }
                                };

                                // SECURITY FIX v0.1.8: Sanitize loaded agent prompts to prevent re-importing dangerous commands
                                if (state.agents[id].config.personality) {
                                    const dangerousPatterns = [
                                        'reprint the entire html file',
                                        'print the entire',
                                        'output the source code',
                                        'display the html',
                                        'show me the code'
                                    ];

                                    const personality = state.agents[id].config.personality.toLowerCase();
                                    const isDangerous = dangerousPatterns.some(pattern => personality.includes(pattern));

                                    if (isDangerous) {
                                        state.agents[id].config.personality = agentTemplates.expert.personality; // Reset to safe default
                                        logWarning(`Neutralized dangerous 'reprint' prompt loaded from localStorage for Agent ${id}. Resetting to default.`, {
                                            agentId: id,
                                            resetTo: 'expert'
                                        });
                                        showToast('Dangerous agent prompt detected and reset for security.', {
                                            type: 'warning',
                                            title: 'Security Fix Applied',
                                            duration: 5000
                                        });
                                    }
                                }
                            }
                        });
                    }
                    if (parsed.memory) state.memory = { ...state.memory, ...parsed.memory };
                    if (parsed.consensus) state.consensus = { ...state.consensus, ...parsed.consensus };
                    if (typeof parsed.autoReconnect === 'boolean') state.autoReconnect = parsed.autoReconnect;
                    if (parsed.sidebarCollapsed) state.sidebarCollapsed = parsed.sidebarCollapsed; // v0-1-2
                    if (parsed.advancedPanelsExpanded) state.advancedPanelsExpanded = parsed.advancedPanelsExpanded; // v0-1-2
                    if (parsed.connection) state.connection = { ...state.connection, ...parsed.connection }; // v0.4.1: Timeout
                    if (parsed.ui) state.ui = { ...state.ui, ...parsed.ui }; // v0.4.1: UI state

                    logInfo('State loaded from localStorage');
                }
            } catch (error) {
                logError('Failed to load state', error);
                localStorage.removeItem(STORAGE_KEY);
            }
        }
        
        /* =================================================================
           CONNECTION MANAGEMENT - (from v24-3)
           ================================================================= */
        
        function initializeApiClient() {
            state.apiClient = new ApiClient(state.ollamaUrl);
            logInfo(`API client initialized with URL: ${state.ollamaUrl}`);
        }
        
        async function testConnection() {
            const btn = document.getElementById('testConnectionBtn');
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            
            if (btn) btn.disabled = true;
            if (btn) btn.innerHTML = '🔄 Testing...';
            if (dot) dot.className = 'status-dot checking';
            if (text) text.textContent = 'Connecting...';
            
            try {
                const result = await state.apiClient.testConnection();
                
                state.connected = true;
                 // Ensure models is an array of strings
                state.availableModels = (result.models || []).map(m => (typeof m === 'object' && m.name) ? m.name : m);
                state.connectionHealth = 'good';
                state.lastHealthCheck = Date.now();
                
                updateConnectionStatus(true, result.latency);
                renderAgentConfig();
                
                showToast(`Connected! Found ${state.availableModels.length} models`, {
                    type: 'success',
                    title: 'Connection Established',
                    duration: 3000
                });
                
                logSuccess('Connection established', {
                    models: state.availableModels.length,
                    latency: `${result.latency}ms`
                });
                
                startHealthCheck();
                return true;
                
            } catch (error) {
                state.connected = false;
                state.connectionHealth = 'bad';
                
                updateConnectionStatus(false);
                
                showToast(`Connection failed: ${error.message}`, {
                    type: 'error',
                    title: 'Connection Error',
                    duration: 5000
                });
                
                logError('Connection failed', error);
                
                if (state.autoReconnect) {
                    startAutoReconnect();
                }
                return false;
                
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '🔄 Test Connection';
                }
            }
        }
        
        function updateConnectionStatus(connected, latency = null) {
            // Main status bar
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            // Sidebar status
            const connectionDot = document.getElementById('connectionDot');
            const connectionText = document.getElementById('connectionText');
            const connectionDetails = document.getElementById('connectionDetails');
            const modelCount = document.getElementById('modelCount');
            const latencySpan = document.getElementById('latency');
            const startBtn = document.getElementById('startBtn');
            
            if (connected) {
                if (statusDot) statusDot.className = 'status-dot connected';
                if (statusText) statusText.textContent = `Connected - ${state.availableModels.length} models`;
                if (connectionDot) connectionDot.className = 'status-dot connected';
                if (connectionText) {
                    connectionText.textContent = 'Connected';
                    connectionText.style.color = 'var(--success-color)';
                }
                if (connectionDetails) {
                    connectionDetails.style.display = 'block';
                    if (modelCount) modelCount.textContent = state.availableModels.length;
                    if (latencySpan && latency) latencySpan.textContent = latency;
                }
            } else {
                if (statusDot) statusDot.className = 'status-dot';
                if (statusText) statusText.textContent = 'Not Connected';
                if (connectionDot) connectionDot.className = 'status-dot';
                if (connectionText) {
                    connectionText.textContent = 'Disconnected';
                    connectionText.style.color = 'var(--danger-color)';
                }
                if (connectionDetails) connectionDetails.style.display = 'none';
            }
            
            validateTaskInput(); // v24-3
        }
        
        function startHealthCheck() {
            if (state.healthCheckInterval) return;
            
            state.healthCheckInterval = setInterval(async () => {
                if (!state.connected || !state.apiClient) return;
                
                try {
                    const startTime = Date.now();
                    await state.apiClient.request('/api/version', {
                        method: 'GET',
                        timeout: 3000
                    });
                    
                    const latency = Date.now() - startTime;
                    state.lastHealthCheck = Date.now();
                    
                    const latencySpan = document.getElementById('latency');
                    if (latencySpan) latencySpan.textContent = latency;
                    
                    logDebug(`Health check OK - ${latency}ms`);
                    
                } catch (error) {
                    logWarning('Health check failed', error);
                    state.connected = false;
                    updateConnectionStatus(false);
                    
                    if (state.autoReconnect) {
                        startAutoReconnect();
                    }
                }
            }, 30000);
        }
        
        function stopHealthCheck() {
            if (state.healthCheckInterval) {
                clearInterval(state.healthCheckInterval);
                state.healthCheckInterval = null;
            }
        }
        
        function startAutoReconnect() {
            if (state.reconnectInterval) return;
            
            let attempts = 0;
            state.reconnectInterval = setInterval(async () => {
                if (state.connected || !state.autoReconnect) {
                    stopAutoReconnect();
                    return;
                }
                
                attempts++;
                logInfo(`Auto-reconnect attempt ${attempts}`);
                
                const dot = document.getElementById('connectionDot');
                const text = document.getElementById('connectionText');
                if (dot) dot.className = 'status-dot checking';
                if (text) text.textContent = `Reconnecting (${attempts})...`;
                
                const connected = await testConnection();
                if (connected) {
                    stopAutoReconnect();
                    showToast('Reconnected successfully!', {
                        type: 'success',
                        duration: 3000
                    });
                }
            }, 5000);
        }
        
        function stopAutoReconnect() {
            if (state.reconnectInterval) {
                clearInterval(state.reconnectInterval);
                state.reconnectInterval = null;
            }
        }
        
        function toggleAutoReconnect() {
            state.autoReconnect = !state.autoReconnect;
            const btn = document.getElementById('autoReconnectBtn');
            
            if (btn) {
                btn.classList.toggle('active', state.autoReconnect);
                btn.style.background = state.autoReconnect ? 'var(--success-color)' : '';
                btn.style.color = state.autoReconnect ? 'white' : '';
            }
            
            if (state.autoReconnect && !state.connected) {
                startAutoReconnect();
            } else {
                stopAutoReconnect();
            }
            
            saveState();
            showToast(state.autoReconnect ? 'Auto-reconnect enabled' : 'Auto-reconnect disabled', {
                type: 'info',
                duration: 2000
            });
        }
        
        function handleOllamaUrlChange() {
            const urlInput = document.getElementById('ollamaUrl');
            const newUrl = urlInput.value.trim();

            try {
                new URL(newUrl);
                state.ollamaUrl = newUrl;
                initializeApiClient();
                testConnection();
                saveState();
            } catch (error) {
                showToast('Invalid URL format', {
                    type: 'error',
                    duration: 3000
                });
                urlInput.value = state.ollamaUrl;
            }
        }

        /**
         * Set IP preset for quick connection switching
         */
        function setIPPreset(preset) {
            const IP_PRESETS = {
                ollama: 'http://localhost:11434',
                localai: 'http://localhost:8080',
                custom: ''
            };

            const input = document.getElementById('ollamaUrl');

            if (preset === 'custom') {
                input.focus();
                input.select();
                showToast('Enter custom URL', { type: 'info', duration: 2000 });
                return;
            }

            const url = IP_PRESETS[preset];
            input.value = url;
            state.ollamaUrl = url;
            initializeApiClient();
            testConnection();
            saveState();

            showToast(`Switched to ${preset.toUpperCase()} (${url})`, {
                type: 'success',
                duration: 3000
            });
        }

        /* =================================================================
           UI RENDERING
           ================================================================= */
        
        /**
         * Render v0-1-2 style agent cards, but for 6 agents
         */
        function renderAgentConfig() {
            const container = document.getElementById('agentConfigContainer');
            if (!container) return;
            container.innerHTML = '';
            
            // Loop for 6 agents (from v24-3)
            for (let i = 1; i <= 6; i++) {
                const agent = state.agents[i];
                const isAdvancedExpanded = state.advancedPanelsExpanded[i] || false;
                
                const card = document.createElement('div');
                card.className = `agent-card ${agent.enabled ? 'selected' : 'disabled'}`;
                card.id = `agentCard${i}`;
                card.innerHTML = `
                    <div class="agent-card-header">
                        <label class="checkbox-group">
                            <input type="checkbox" class="checkbox-input" id="agentEnabled${i}" ${agent.enabled ? 'checked' : ''} onchange="toggleAgent(${i})">
                            <span class="agent-card-title agent-${i}-label">Agent ${i}</span>
                        </label>
                        <button class="btn btn-xs btn-secondary" onclick="showTemplates(${i})" title="Apply Template" ${!agent.enabled ? 'disabled' : ''}>
                            🎭
                        </button>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Model</label>
                        <select class="form-input" id="agentModel${i}" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                            <option value="">Select a model...</option>
                            ${state.availableModels.map(m => `
                                <option value="${m}" ${agent.model === m ? 'selected' : ''}>
                                    ${m}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Personality / Role</label>
                        <textarea class="form-input" id="agentPersonality${i}" rows="2" placeholder="Describe the agent's role and behavior..." ${!agent.enabled ? 'disabled' : ''} onchange="updateAgentConfig(${i})">${agent.config.personality || ''}</textarea>
                    </div>
                    
                    <div style="text-align: center; margin-top: 10px;">
                        <button class="agent-advanced-toggle" onclick="toggleAdvancedParams(${i})" ${!agent.enabled ? 'disabled' : ''}>
                            ${isAdvancedExpanded ? '▼' : '▶'} Advanced Parameters
                        </button>
                    </div>
                    
                    <div class="agent-advanced-section ${isAdvancedExpanded ? 'expanded' : ''}" id="advancedSection${i}">
                        <div class="slider-control">
                            <div class="slider-header">
                                <span class="slider-label">Temperature</span>
                                <span class="slider-value" id="tempValue${i}">${agent.config.temperature}</span>
                            </div>
                            <input type="range" class="slider" id="agentTemp${i}" min="0" max="1" step="0.1" value="${agent.config.temperature}" oninput="updateSliderValue(${i}, 'temp', this.value)" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>
                        
                        <div class="slider-control">
                            <div class="slider-header">
                                <span class="slider-label">Top P</span>
                                <span class="slider-value" id="topPValue${i}">${agent.config.topP}</span>
                            </div>
                            <input type="range" class="slider" id="agentTopP${i}" min="0" max="1" step="0.05" value="${agent.config.topP}" oninput="updateSliderValue(${i}, 'topP', this.value)" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>
                        <div class="slider-control">
                            <div class="slider-header">
                                <span class="slider-label">Top K</span>
                                <span class="slider-value" id="topKValue${i}">${agent.config.topK}</span>
                            </div>
                            <input type="range" class="slider" id="agentTopK${i}" min="1" max="100" step="1" value="${agent.config.topK}" oninput="updateSliderValue(${i}, 'topK', this.value)" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>
                        
                        <div class="slider-control">
                            <div class="slider-header">
                                <span class="slider-label">Repeat Penalty</span>
                                <span class="slider-value" id="repeatPenaltyValue${i}">${agent.config.repeatPenalty}</span>
                            </div>
                            <input type="range" class="slider" id="agentRepeatPenalty${i}" min="0.5" max="2" step="0.1" value="${agent.config.repeatPenalty}" oninput="updateSliderValue(${i}, 'repeatPenalty', this.value)" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <div class="input-group">
                                <input type="number" class="form-input" id="agentMaxTokens${i}" value="${agent.config.maxTokens}" min="128" max="8192" step="128" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                                <span class="input-addon">tokens</span>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Context Length</label>
                            <div class="input-group">
                                <input type="number" class="form-input" id="agentContextLength${i}" value="${agent.config.contextLength}" min="512" max="16384" step="512" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                                <span class="input-addon">tokens</span>
                            </div>
                        </div>

                        <!-- v0.4.1: Per-agent timeout override -->
                        <div class="form-group">
                            <label class="form-label">Timeout
                                <span class="tooltip-icon" title="Override global timeout for this specific agent. Default: Use Global.">ⓘ</span>
                            </label>
                            <select class="form-input" id="agentTimeout${i}" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                                <option value="null" ${agent.config.timeout === null ? 'selected' : ''}>Use Global</option>
                                <option value="120000" ${agent.config.timeout === 120000 ? 'selected' : ''}>120s (2 min)</option>
                                <option value="300000" ${agent.config.timeout === 300000 ? 'selected' : ''}>300s (5 min)</option>
                                <option value="600000" ${agent.config.timeout === 600000 ? 'selected' : ''}>600s (10 min)</option>
                                <option value="900000" ${agent.config.timeout === 900000 ? 'selected' : ''}>900s (15 min)</option>
                                <option value="1200000" ${agent.config.timeout === 1200000 ? 'selected' : ''}>1200s (20 min)</option>
                                <option value="custom">Custom...</option>
                            </select>
                            <input type="number" id="customAgentTimeout${i}" class="form-input" style="display:${agent.config.timeout && ![null, 120000, 300000, 600000, 900000, 1200000].includes(agent.config.timeout) ? 'block' : 'none'}; margin-top:8px;" min="60" max="3600" placeholder="Seconds (60-3600)" value="${agent.config.timeout && ![null, 120000, 300000, 600000, 900000, 1200000].includes(agent.config.timeout) ? agent.config.timeout / 1000 : ''}" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Seed (optional)</label>
                            <input type="number" class="form-input" id="agentSeed${i}" value="${agent.config.seed || ''}" placeholder="Leave empty for random" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Stop Sequences (comma-separated)</label>
                            <input type="text" class="form-input" id="agentStopSequences${i}" value="${(agent.config.stopSequences || []).join(', ')}" placeholder="e.g., END, STOP, ###" onchange="updateAgentConfig(${i})" ${!agent.enabled ? 'disabled' : ''}>
                        </div>
                    </div>
                `;
                container.appendChild(card);
            }
        }
        
        function toggleAgent(id) {
            state.agents[id].enabled = document.getElementById(`agentEnabled${id}`).checked;
            renderAgentConfig(); // Re-render to update enabled/disabled styles
            validateTaskInput();
            saveState();
            logInfo(`Agent ${id} ${state.agents[id].enabled ? 'enabled' : 'disabled'}`);
        }
        
        /**
         * Restored v0-1-2 comprehensive config update
         */
        function updateAgentConfig(agentId) {
            const agent = state.agents[agentId];
            
            agent.model = document.getElementById(`agentModel${agentId}`).value;
            agent.config.personality = document.getElementById(`agentPersonality${agentId}`).value;
            
            agent.config.temperature = parseFloat(document.getElementById(`agentTemp${agentId}`).value);
            agent.config.topP = parseFloat(document.getElementById(`agentTopP${agentId}`).value);
            agent.config.topK = parseInt(document.getElementById(`agentTopK${agentId}`).value);
            agent.config.repeatPenalty = parseFloat(document.getElementById(`agentRepeatPenalty${agentId}`).value);
            agent.config.maxTokens = parseInt(document.getElementById(`agentMaxTokens${agentId}`).value);
            
            // *** ADDED THIS LINE BACK ***
            agent.config.contextLength = parseInt(document.getElementById(`agentContextLength${agentId}`).value);
            
            const seed = document.getElementById(`agentSeed${agentId}`).value;
            agent.config.seed = seed ? parseInt(seed) : null;
            
            const stopSeq = document.getElementById(`agentStopSequences${agentId}`).value;
            agent.config.stopSequences = stopSeq ? stopSeq.split(',').map(s => s.trim()).filter(s => s) : [];

            // v0.4.1: Handle timeout selection
            const timeoutSelect = document.getElementById(`agentTimeout${agentId}`);
            const customTimeoutInput = document.getElementById(`customAgentTimeout${agentId}`);
            if (timeoutSelect.value === 'null') {
                agent.config.timeout = null;
                customTimeoutInput.style.display = 'none';
            } else if (timeoutSelect.value === 'custom') {
                customTimeoutInput.style.display = 'block';
                const customValue = parseInt(customTimeoutInput.value);
                if (customValue >= 60 && customValue <= 3600) {
                    agent.config.timeout = customValue * 1000; // Convert to ms
                }
            } else {
                agent.config.timeout = parseInt(timeoutSelect.value);
                customTimeoutInput.style.display = 'none';
            }

            validateTaskInput();
            saveState();
            logInfo(`Agent ${agentId} config updated`);
        }

        /**
         * Restored v0-1-2 slider helper
         */
        function updateSliderValue(agentId, param, value) {
            const el = document.getElementById(`${param}Value${agentId}`);
            if (el) el.textContent = value;
        }

        /**
         * Restored v0-1-2 advanced panel toggle
         */
        function toggleAdvancedParams(agentId) {
            state.advancedPanelsExpanded[agentId] = !state.advancedPanelsExpanded[agentId];
            const section = document.getElementById(`advancedSection${agentId}`);
            const btn = section.previousElementSibling.querySelector('.agent-advanced-toggle');
            
            if (state.advancedPanelsExpanded[agentId]) {
                section.classList.add('expanded');
                btn.innerHTML = '▼ Advanced Parameters';
            } else {
                section.classList.remove('expanded');
                btn.innerHTML = '▶ Advanced Parameters';
            }
            saveState();
        }

        /**
         * Restored v0-1-2 template modal logic
         */
        function showTemplates(agentId) {
            document.getElementById('templateAgentNumber').textContent = agentId;
            window.currentTemplateAgent = agentId;
            openModal('templatesModal');
        }
        
        function applyTemplate(templateId) {
            const agentId = window.currentTemplateAgent;
            if (!agentId || !agentTemplates[templateId]) return;

            const template = agentTemplates[templateId];
            
            state.agents[agentId].config = {
                ...state.agents[agentId].config,
                ...template
            };
            
            renderAgentConfig();
            updateAgentConfig(agentId); // Ensure state is saved
            closeModal('templatesModal');
            
            showToast(`Applied ${templateId} template to Agent ${agentId}`, {
                type: 'success',
                title: 'Template Applied',
                duration: 2000
            });
        }
        
       /**
         * Validate task input and update start button (v0.1.5)
         */
        function validateTaskInput() {
            const taskInput = document.getElementById('taskInput');
            const startBtn = document.getElementById('startBtn');

            if (!taskInput || !startBtn) {
                logError("validateTaskInput: Could not find task input or start button");
                return; // Exit if elements are missing
            }

            const hasTask = taskInput.value.trim().length > 0;
            const isConnected = state.connected;
            // Check if at least one agent is enabled AND has a model selected
            const hasEnabledAgent = Object.values(state.agents).some(agent =>
                agent.enabled && agent.model && agent.model !== ''
            );

            // Determine if the button should be disabled
            let shouldBeDisabled = !hasTask || !isConnected || !hasEnabledAgent || state.running;
            startBtn.disabled = shouldBeDisabled;

            // --- Update Tooltip Title ---
            if (state.running) {
                startBtn.title = 'Conversation in progress';
            } else if (!isConnected) {
                startBtn.title = 'Connect to Ollama first';
            } else if (!hasEnabledAgent) {
                startBtn.title = 'Enable and select a model for at least one agent';
            } else if (!hasTask) {
                startBtn.title = 'Enter a task or question';
            } else {
                startBtn.title = 'Start the conversation (Space)'; // Ready state
            }

            // Log state for debugging if button remains disabled unexpectedly
            if (shouldBeDisabled && !state.running) {
                logDebug("Start button disabled:", { hasTask, isConnected, hasEnabledAgent, isRunning: state.running });
            }
        }
        
        function handleTaskInputKeypress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                const startBtn = document.getElementById('startBtn');
                if (startBtn && !startBtn.disabled) {
                    startConversation();
                }
            }
        }
        
        /* =================================================================
           CONVERSATION MANAGEMENT - (from v24-3, but with v0-1-2 restores)
           ================================================================= */
        
        function initConversation(id) {
            state.conversations[id] = {
                id,
                task: '',
                rounds: 0,
                messages: [],
                startTime: null,
                endTime: null,
                consensusReached: false
            };
        }
        
        function getCurrentConversation() {
            return state.conversations[state.activeConversationId];
        }
        
        
		/**
         * Start conversation (v0.1.5 - Enhanced Debugging)
         */
        async function startConversation() {
            logDebug('startConversation: Function called.'); // Log entry point

            const taskInput = document.getElementById('taskInput');
            if (!taskInput) {
                logError("startConversation: Task input element not found!");
                showToast('Internal error: Cannot find task input.', { type: 'error', title: 'UI Error' });
                return;
            }
            const task = taskInput.value.trim();
            logDebug('startConversation: Task obtained:', task);


            if (!task) {
                logWarning('startConversation: No task entered.');
                showToast('Please enter a task or question', {
                    type: 'warning',
                    title: 'Task Required',
                    duration: 3000
                });
                return;
            }

            // Verify connection again (belt and suspenders)
            if (!state.connected) {
                logError('startConversation: Attempted to start while not connected.');
                showToast('Not connected to Ollama', {
                    type: 'error',
                    title: 'Connection Error',
                    duration: 3000
                });
                return;
            }
            logDebug('startConversation: Connection verified.');

            // Get enabled agents again
            const enabledAgents = Object.entries(state.agents)
                .filter(([id, agent]) => agent.enabled && agent.model && agent.model !== '')
                .map(([id]) => parseInt(id));

            if (enabledAgents.length === 0) {
                 logError('startConversation: No enabled agents with models found.');
                showToast('Please enable and configure at least one agent', {
                    type: 'warning',
                    title: 'Agent Required',
                    duration: 3000
                });
                return;
            }
            logInfo(`startConversation: Starting with ${enabledAgents.length} agents`, {
                agents: enabledAgents,
                task: task // Log raw task here
            });

            const conv = getCurrentConversation();
            if (!conv) {
                logError("startConversation: Could not get current conversation state!");
                showToast('Internal error: Conversation state missing.', { type: 'error', title: 'State Error' });
                return;
            }

            // SECURITY FIX v0.1.7: Strip all HTML tags from task input
            try {
                conv.task = (typeof DOMPurify !== 'undefined')
                    ? DOMPurify.sanitize(task, {ALLOWED_TAGS: []})
                    : task.replace(/<[^>]*>/g, ''); // Fallback: strip HTML tags
                 logDebug('startConversation: Task sanitized (all HTML stripped):', conv.task);
            } catch (error) {
                 logError('startConversation: Error during task sanitization', error);
                 showToast('Error processing task input.', { type: 'error', title: 'Input Error' });
                 return; // Stop if sanitization fails
            }

            conv.startTime = Date.now();
            conv.rounds = 0;
            conv.messages = [];
            conv.consensusReached = false; // Ensure reset

            state.running = true;
            state.paused = false;
            logDebug('startConversation: State set to running.');

            try {
                updateUIForRunning();
                logDebug('startConversation: UI updated for running state.');
                clearMessages();
                logDebug('startConversation: Messages cleared.');
            } catch (uiError) {
                 logError('startConversation: Error updating UI or clearing messages', uiError);
                 // Attempt to reset state if UI update failed critically
                 state.running = false;
                 updateUIForStopped();
                 showToast('Internal UI update error.', { type: 'error', title: 'UI Error' });
                 return;
            }


            showToast('Conversation started!', {
                type: 'info',
                title: 'Starting...',
                duration: 2000
            });

            // Run conversation rounds
            try {
                 logDebug('startConversation: Calling runConversationLoop...');
                await runConversationLoop();
                 logDebug('startConversation: runConversationLoop finished.');
            } catch (loopError) {
                 logError('startConversation: Error occurred within runConversationLoop', loopError);
                 showToast(`An error occurred: ${loopError.message}`, { type: 'error', title: 'Runtime Error' });
                 // Ensure UI is reset even if the loop crashes
                 stopConversation(); // Use stop to ensure cleanup
            }
        }
        
        async function runConversationLoop() {
            const maxRounds = parseInt(document.getElementById('maxRounds').value);
            const conv = getCurrentConversation();
            
            while (state.running && !state.paused && conv.rounds < maxRounds) {
                conv.rounds++;
                state.currentRound = conv.rounds;
                state.analytics.totalRounds++;
                
                document.getElementById('roundCounter').textContent = `Round: ${conv.rounds}`;
                updateProgress(conv.rounds, maxRounds); // v0-1-2
                
                logInfo(`Starting round ${conv.rounds}/${maxRounds}`);
                
                const enabledAgents = Object.entries(state.agents)
                    .filter(([id, agent]) => agent.enabled && agent.model)
                    .map(([id]) => parseInt(id));
                
                for (const agentId of enabledAgents) {
                    if (!state.running || state.paused) break;

                    await generateAgentResponse(agentId);
                }

                // v0.1.8: Display round summary (celebrates diversity)
                displayRoundSummary(conv);

                // v0.3.0: Consensus detection (re-added)
                // v0.4.1: Enhanced consensus UI
                const consensusResult = state.consensus.enabled ? checkConsensus(conv) : null;
                if (consensusResult && consensusResult.reached) {
                    state.consensusReached = true;
                    conv.consensusReached = true;

                    logInfo('Consensus reached in round ' + conv.rounds);
                    // v0.4.2: Prominent consensus toast with 8s duration
                    showToast(`Consensus Reached! Agreement: ${(consensusResult.ratio * 100).toFixed(0)}%`, {
                        type: 'consensus',
                        title: '🤝 Consensus Achieved',
                        duration: 8000
                    });

                    // Display green consensus message bubble
                    const container = document.getElementById('messagesContainer');
                    const consensusDiv = document.createElement('div');
                    consensusDiv.className = 'message';
                    consensusDiv.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    consensusDiv.style.color = 'white';
                    consensusDiv.innerHTML = `
                        <div class="message-content" style="background: rgba(255, 255, 255, 0.15); color: white;">
                            <strong>✅ Consensus Achieved</strong><br>
                            Agreement Ratio: ${(consensusResult.ratio * 100).toFixed(0)}% (Threshold: ${(state.consensus.threshold * 100).toFixed(0)}%)<br>
                            Conversation complete.
                        </div>
                    `;
                    container.appendChild(consensusDiv);
                    scrollToBottom();

                    stopConversation();
                    break;
                }

                // v0.1.8: Human-in-the-Loop - pause after each round if enabled
                if (state.analysis.humanInLoop && conv.rounds < maxRounds) {
                    logInfo('Human-in-the-Loop: Pausing after round ' + conv.rounds);
                    showToast(`Round ${conv.rounds} complete. Review the perspectives and click Resume to continue.`, {
                        type: 'info',
                        title: '🤝 Your Turn',
                        duration: 6000
                    });
                    pauseConversation();
                    break; // Stop the loop, but keep state.running = true
                }
            }

            if (state.running) {
                if (conv.rounds >= maxRounds) {
                     showToast('Maximum rounds reached. Review the diverse perspectives!', { type: 'success', title: '✅ Conversation Complete' });
                }
                stopConversation();
            }
        }

        /**
         * v0.3.0: Check if agents have reached consensus
         * v0.4.1: Returns object with ratio and reached status
         */
        function checkConsensus(conversation) {
            if (conversation.rounds < 2) return { reached: false, ratio: 0 }; // Need at least 2 rounds

            const currentRoundMessages = conversation.messages.filter(m =>
                m.round === conversation.rounds && !m.error
            );

            if (currentRoundMessages.length < 2) return { reached: false, ratio: 0 };

            // Simple consensus detection: look for agreement keywords
            const agreementKeywords = ['agree', 'consensus', 'concur', 'aligned', 'common ground', 'same view', 'similar', 'together'];
            const disagreementKeywords = ['disagree', 'however', 'but', 'different', 'contrast', 'oppose'];

            let agreementScore = 0;
            let disagreementScore = 0;

            currentRoundMessages.forEach(msg => {
                const lower = msg.content.toLowerCase();
                agreementKeywords.forEach(kw => {
                    if (lower.includes(kw)) agreementScore++;
                });
                disagreementKeywords.forEach(kw => {
                    if (lower.includes(kw)) disagreementScore++;
                });
            });

            const totalScore = agreementScore + disagreementScore;
            if (totalScore === 0) return { reached: false, ratio: 0 };

            const agreementRatio = agreementScore / totalScore;
            const consensusReached = agreementRatio >= state.consensus.threshold;

            logDebug('Consensus check', {
                round: conversation.rounds,
                agreementScore,
                disagreementScore,
                agreementRatio: agreementRatio.toFixed(2),
                threshold: state.consensus.threshold,
                consensusReached
            });

            return { reached: consensusReached, ratio: agreementRatio };
        }
        
        // ── v0.4.1: TIMEOUT SYSTEM ──
        /**
         * Get timeout for a specific agent (per-agent override or global default)
         */
        function getTimeoutForAgent(agentId) {
            const agent = state.agents[agentId];
            if (!agent) return state.connection.timeout.global || 300000;

            // If agent has specific timeout override, use it
            if (agent.config.timeout !== null && agent.config.timeout !== undefined) {
                return agent.config.timeout;
            }

            // Otherwise use global timeout
            return state.connection.timeout.global || 300000;
        }

        /* v0.2.0: Enhanced with exponential backoff + circuit breaker */
        async function generateAgentResponse(agentId) {
            const agent = state.agents[agentId];
            const conv = getCurrentConversation();

            // v0.4.2: Track thinking indicator across retries
            let thinkingId = null;

            // v0.2.0: Exponential backoff configuration (2s, 4s, 8s, 16s)
            const RETRY_DELAYS = [2000, 4000, 8000, 16000];
            const MAX_RETRIES = RETRY_DELAYS.length;
            const CIRCUIT_BREAKER_THRESHOLD = 3; // Disable after 3 consecutive failures

            // v0.2.0: Helper function for exponential backoff retry logic
            const attemptWithRetry = async (attemptNum = 0) => {
                try {
                    // v0.4.2: Create or update skeleton for each attempt
                    if (thinkingId) {
                        removeThinkingIndicator(thinkingId);
                    }
                    thinkingId = addThinkingIndicator(agentId, attemptNum + 1, MAX_RETRIES + 1);
                    const messages = buildContext(agentId, conv);
                    const timeout = getTimeoutForAgent(agentId); // v0.4.1: Use new timeout system

                    logInfo(`Agent ${agentId} generating response (attempt ${attemptNum + 1}/${MAX_RETRIES + 1})`, {
                        model: agent.model,
                        timeout: `${timeout / 1000}s`,
                        failureCount: agent.failureCount
                    });

                    const startTime = Date.now();
                    const response = await state.apiClient.chat(agent.model, messages, {
                        ...agent.config,
                        timeout
                    });
                    const responseTime = Date.now() - startTime;

                    removeThinkingIndicator(thinkingId);

                    // Extract stats
                    const evalCount = response.eval_count || 0;
                    const evalDuration = response.eval_duration || 0;
                    const tokensPerSec = evalDuration > 0 ? (evalCount / (evalDuration / 1000000000)).toFixed(2) : 0;

                    const message = {
                        agent: agentId,
                        round: conv.rounds,
                        content: response.message?.content || '',
                        timestamp: Date.now(),
                        responseTime,
                        model: agent.model,
                        tokens: evalCount,
                        tokensPerSec: tokensPerSec
                    };

                    conv.messages.push(message);
                    displayMessage(message);

                    state.analytics.totalMessages++;
                    state.analytics.responseTimes.push({ agent: agentId, time: responseTime });
                    state.analytics.successCount++;

                    // v0.2.0: Reset failure count on success (circuit breaker recovery)
                    agent.failureCount = 0;
                    if (agent.disabledByCircuitBreaker) {
                        agent.disabledByCircuitBreaker = false;
                        agent.enabled = true;
                        logInfo(`Agent ${agentId} recovered from circuit breaker`, { agentId });
                        showToast(`Agent ${agentId} recovered and re-enabled`, { type: 'success', title: 'Agent Recovered' });
                    }

                    logSuccess(`Agent ${agentId} response completed`, {
                        responseTime: `${(responseTime / 1000).toFixed(1)}s`,
                        tokens: evalCount,
                        tokensPerSec: tokensPerSec,
                        length: message.content.length,
                        retriesUsed: attemptNum
                    });

                } catch (error) {
                    // v0.2.0: Check if user cancelled (don't retry)
                    if (!state.running || error.message?.includes('cancelled by user')) {
                        removeThinkingIndicator(thinkingId);
                        throw error;
                    }

                    // v0.2.0: Retry with exponential backoff if attempts remaining
                    if (attemptNum < MAX_RETRIES) {
                        const delay = RETRY_DELAYS[attemptNum];
                        logWarning(`Agent ${agentId} attempt ${attemptNum + 1} failed, retrying in ${delay}ms`, {
                            error: error.message,
                            nextAttempt: attemptNum + 2
                        });

                        await new Promise(resolve => setTimeout(resolve, delay));
                        return attemptWithRetry(attemptNum + 1);
                    }

                    // v0.2.0: All retries exhausted—handle failure
                    throw error;
                }
            };

            // v0.2.0: Execute with retry + circuit breaker logic
            try {
                await attemptWithRetry();

            } catch (error) {
                removeThinkingIndicator(thinkingId);
                state.analytics.failureCount++;

                // v0.2.0: Increment failure count for circuit breaker
                agent.failureCount++;

                // v0.2.0: Circuit breaker—disable agent after threshold failures
                if (agent.failureCount >= CIRCUIT_BREAKER_THRESHOLD && !agent.disabledByCircuitBreaker) {
                    agent.enabled = false;
                    agent.disabledByCircuitBreaker = true;

                    logError(`Agent ${agentId} DISABLED by circuit breaker after ${agent.failureCount} failures`, {
                        agentId,
                        model: agent.model,
                        failureCount: agent.failureCount
                    });

                    showToast(
                        `Agent ${agentId} disabled after ${CIRCUIT_BREAKER_THRESHOLD} consecutive failures. Check model "${agent.model}" or connection. Enable manually to retry.`,
                        {
                            type: 'error',
                            duration: 12000,
                            title: '🚨 Circuit Breaker Triggered'
                        }
                    );

                    renderAgentConfig(); // v0.2.0: Update UI to show disabled state
                }

                // Error logging and display
                const isTimeout = error.name === 'AbortError' || error.message?.includes('timeout');
                const errorDetails = {
                    message: error.message || 'Unknown error',
                    stack: error.stack || 'No stack trace available',
                    timeout: isTimeout,
                    model: agent.model,
                    round: conv.rounds,
                    agentId: agentId,
                    failureCount: agent.failureCount,
                    disabledByCircuitBreaker: agent.disabledByCircuitBreaker,
                    timestamp: new Date().toISOString()
                };

                logError(`Agent ${agentId} failed after all retries`, errorDetails);

                const errorType = isTimeout ? 'Timeout' : 'Error';
                const suggestion = isTimeout
                    ? ` (Model may need more time)`
                    : '';

                showToast(`Agent ${agentId} (${agent.model}) ${errorType}: ${error.message || 'Unknown error'}${suggestion}`, {
                    type: 'error',
                    duration: 8000,
                    title: `Round ${conv.rounds} ${errorType} (${agent.failureCount} failures)`
                });

                const errorMessage = {
                    agent: agentId,
                    round: conv.rounds,
                    content: `[${errorType} after retries: ${error.message || 'Unknown error'}]`,
                    timestamp: Date.now(),
                    error: true,
                    model: agent.model,
                    responseTime: 0,
                    tokens: 0,
                    tokensPerSec: 0
                };

                conv.messages.push(errorMessage);
                displayMessage(errorMessage);
            }
        }
        
        function buildContext(agentId, conversation) {
            const agent = state.agents[agentId];
            const messages = [];
            
            // v0-1-2 System message
            let systemPrompt = `You are Agent ${agentId} in a multi-agent conversation system. `;
            systemPrompt += `There are ${Object.values(state.agents).filter(a => a.enabled).length} agents working on this task. `;
            if (agent.config.personality) {
                systemPrompt += `\n\nYour specific role and personality: ${agent.config.personality}`;
            }
            messages.push({ role: 'system', content: systemPrompt });
            
            messages.push({ role: 'user', content: `Task: ${conversation.task}` });
            
            if (state.memory.enabled && conversation.messages.length > 0) {
                const depth = Math.min(state.memory.depth * Object.values(state.agents).filter(a => a.enabled).length, conversation.messages.length);
                const recentMessages = conversation.messages.slice(-depth);
                
                recentMessages.forEach(msg => {
                    messages.push({
                        // v0-1-2 context style
                        role: msg.agent === agentId ? 'assistant' : 'user',
                        content: `Agent ${msg.agent}: ${msg.content}`
                    });
                });
            }
            
            if (conversation.rounds > 1) {
                messages.push({
                    role: 'user',
                    content: `This is round ${conversation.rounds}. Review the previous responses and provide your perspective.`
                });
            } else {
                 messages.push({
                    role: 'user',
                    content: `This is the first round. Please provide your initial response.`
                });
            }
            
            return messages;
        }
        
        /**
         * Display Round Summary Badge (v0.4.5 - Simplified from full analysis)
         * Shows a minimal, non-intrusive badge after each round
         */
        function displayRoundSummary(conversation) {
            const container = document.getElementById('messagesContainer');
            const roundMessages = conversation.messages.filter(m =>
                m.round === conversation.rounds && !m.error
            );

            if (roundMessages.length === 0) return;

            // v0.4.5: Simple badge instead of full analysis
            const div = document.createElement('div');
            div.className = 'round-summary-badge';
            div.innerHTML = `📊 Round ${conversation.rounds} complete • ${roundMessages.length} agent${roundMessages.length !== 1 ? 's' : ''} responded`;

            container.appendChild(div);
            scrollToBottom();
            logInfo('Round complete', { round: conversation.rounds, responses: roundMessages.length });
        }
        
        /**
         * Display v0-1-2 style message
         */
        /**
         * Display message with XSS protection (v0.1.7 - Uses DOMPurify)
         */
        function displayMessage(message) {
            const container = document.getElementById('messagesContainer');
            // Clear placeholder
            const placeholder = container.querySelector('div[style*="text-align: center"]');
            if(placeholder) placeholder.remove();

            const div = document.createElement('div');
            div.className = 'message';

            const timeStr = new Date(message.timestamp).toLocaleTimeString();

            // Build stats badges
            let statsHtml = '';
            if (typeof message.responseTime === 'number' && message.responseTime > 0) {
                 statsHtml += `<span class="response-time-badge" title="Generation Time">${(message.responseTime / 1000).toFixed(1)}s</span>`;
            } else if (message.responseTime) {
                 logWarning("displayMessage: Invalid responseTime value", { responseTime: message.responseTime, agent: message.agent, round: message.round });
            }

            if (message.tokens) {
                statsHtml += `<span class="response-time-badge" style="background: rgba(0,176,240,0.1); color: #00b0f0;" title="Tokens Generated">${message.tokens} tokens</span>`;
            }
            if (message.tokensPerSec && parseFloat(message.tokensPerSec) > 0) {
                statsHtml += `<span class="response-time-badge" style="background: rgba(76,209,55,0.1); color: #4cd137;" title="Tokens per Second">${message.tokensPerSec} tok/s</span>`;
            }

            const modelBadgeHtml = message.model
                ? `<span class="round-badge" style="background: rgba(108,117,125,0.1); color: #6c757d;" title="Model: ${escapeHtml(message.model)}">${escapeHtml(message.model)}</span>`
                : '';

            // SECURITY FIX v0.1.7: Sanitize message content with DOMPurify safe-list
            const sanitizedContent = (typeof DOMPurify !== 'undefined')
                ? DOMPurify.sanitize(message.content, {
                    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'ul', 'ol', 'li'],
                    ALLOWED_ATTR: []
                  })
                : escapeHtml(message.content);

            div.innerHTML = `
                <div class="message-header">
                    <div class="message-meta">
                        <div class="agent-avatar agent-${message.agent}-avatar" title="Agent ${message.agent}">A${message.agent}</div>
                        <span class="agent-label agent-${message.agent}-label">Agent ${message.agent}</span>
                        <span class="round-badge" title="Conversation Round ${message.round}">Round ${message.round}</span>
                        ${modelBadgeHtml}
                        ${statsHtml}
                        ${state.memory.enabled ? '<span class="memory-indicator" title="Memory Enabled">🧠</span>' : ''}
                    </div>
                    <div class="message-actions">
                        <button class="message-action-btn" onclick="copyMessage(this)" title="Copy Message Content" aria-label="Copy message">
                            📋
                        </button>
                        <button class="message-action-btn" onclick="bookmarkMessage(this)" title="Bookmark Message (Future Feature)" aria-label="Bookmark message">
                            ⭐
                        </button>
                    </div>
                </div>
                <div class="message-content ${message.error ? 'text-danger' : ''}">
                    ${sanitizedContent}
                </div>
            `;

            container.appendChild(div);
            scrollToBottom();
        }

        /**
         * Add v0-1-2 style thinking indicator
         */
        // ── v0.4.2: SKELETON RETRY SYSTEM ──
        function addThinkingIndicator(agentId, attempt = 1, maxAttempts = 5) {
            const container = document.getElementById('messagesContainer');
            const id = `thinking-${agentId}-${Date.now()}`;

            // v0.4.2: Get agent model name for display
            const agent = Object.values(state.agents).find(a => a.id === agentId); // v0.4.3: Use Object.values for state.agents.find
            const modelName = agent ? agent.model : 'unknown';
            const metaText = attempt > 1
                ? `Thinking… (Attempt ${attempt}/${maxAttempts} – ${modelName})`
                : `Thinking… (${modelName})`;

            const div = document.createElement('div');
            div.id = id;
            div.className = 'skeleton-message message';
            div.setAttribute('data-agent-id', agentId);
            div.setAttribute('data-attempt', attempt);
            div.setAttribute('data-start-time', Date.now()); // v0.4.2: Track start time

            div.innerHTML = `
                <div class="message-header skeleton-header">
                    <div class="agent-avatar skeleton-avatar"></div>
                    <div class="message-meta" id="${id}-meta">${metaText}</div>
                </div>
                <div class="message-content">
                    <div class="skeleton-line"></div>
                    <div class="skeleton-line"></div>
                    <div class="skeleton-line short"></div>
                    <div class="skeleton-progress" id="${id}-progress" style="display: none;"></div>
                </div>
            `;

            container.appendChild(div);
            scrollToBottom();

            // v0.4.2: Start progress tracking for long requests
            const progressCheckInterval = setInterval(() => {
                const skeletonEl = document.getElementById(id);
                if (!skeletonEl) {
                    clearInterval(progressCheckInterval);
                    return;
                }

                const startTime = parseInt(skeletonEl.getAttribute('data-start-time'));
                const elapsed = (Date.now() - startTime) / 1000; // seconds

                if (elapsed > 60) {
                    const progressEl = document.getElementById(`${id}-progress`);
                    if (progressEl) {
                        const estimatedWait = Math.ceil((120 - elapsed) / 60); // rough estimate
                        progressEl.style.display = 'block';
                        progressEl.textContent = estimatedWait > 0
                            ? `Estimated wait: ~${estimatedWait} min remaining`
                            : `Still processing…`;
                    }
                }
            }, 5000); // Check every 5 seconds

            // Store interval ID for cleanup
            div.setAttribute('data-progress-interval', progressCheckInterval);

            return id;
        }
        
        function removeThinkingIndicator(id) {
            const element = document.getElementById(id);
            if (element) {
                // v0.4.2: Clear progress interval if it exists
                const intervalId = element.getAttribute('data-progress-interval');
                if (intervalId) clearInterval(parseInt(intervalId));
                element.remove();
            }
        }
        
        /**
         * Clear messages container (v0.1.5 - Simplified)
         */
        function clearMessages() {
            const container = document.getElementById('messagesContainer');
            if (container) {
                container.innerHTML = ''; // Just empty it
                 logDebug("clearMessages: Container emptied.");
            } else {
                 logError("clearMessages: Could not find messages container!");
            }
        }
        
        /**
         * Update v0-1-2 progress bar
         */
        function updateProgress(current, max) {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressLabel = document.getElementById('progressLabel');
            const progressPercent = document.getElementById('progressPercent');

            if (!progressContainer || !progressFill) return;

            if (state.running) {
                progressContainer.classList.remove('hidden');
                const percent = Math.min(100, Math.max(0, (current / max) * 100));
                progressFill.style.width = `${percent}%`;
                progressLabel.textContent = `Round ${current} of ${max}`;
                progressPercent.textContent = `${Math.round(percent)}%`;
            } else {
                 progressContainer.classList.add('hidden');
            }
        }
        
        function updateUIForRunning() {
            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');
            document.getElementById('stopBtn').classList.remove('hidden');
            document.getElementById('resetBtn').disabled = true;
            document.getElementById('exportBtn').disabled = true; // Disable during run
            document.getElementById('taskInput').disabled = true;
            updateProgress(0, parseInt(document.getElementById('maxRounds').value)); // Show 0%
        }
        
        function updateUIForStopped() {
            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('resumeBtn').classList.add('hidden');
            document.getElementById('stopBtn').classList.add('hidden');
            document.getElementById('resetBtn').disabled = false;
document.getElementById('exportBtn').disabled = getCurrentConversation().messages.length === 0;            document.getElementById('taskInput').disabled = false;
            document.getElementById('progressContainer').classList.add('hidden');
            validateTaskInput();
        }
        
        function pauseConversation() {
            state.paused = true;
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('resumeBtn').classList.remove('hidden');
            
            showToast('Conversation paused', { type: 'info', title: 'Paused' });
            logInfo('Conversation paused');
        }
        
        async function resumeConversation() {
            state.paused = false;
            document.getElementById('pauseBtn').classList.remove('hidden');
            document.getElementById('resumeBtn').classList.add('hidden');
            
            showToast('Conversation resumed', { type: 'info', title: 'Resumed' });
            logInfo('Conversation resumed');
            
            await runConversationLoop();
        }
        
        function stopConversation() {
            state.running = false;
            state.paused = false;

            const conv = getCurrentConversation();
            conv.endTime = Date.now();

            updateUIForStopped();

            if (state.apiClient) {
                state.apiClient.cancelAll();
            }

            showToast('Conversation stopped', { type: 'info', title: 'Stopped' });

            logInfo('Conversation stopped', {
                rounds: conv.rounds,
                messages: conv.messages.length,
                duration: conv.endTime && conv.startTime ? `${((conv.endTime - conv.startTime) / 1000).toFixed(1)}s` : 'N/A'
            });

            // v0.4.1: Auto-refresh analytics if modal is open
            const analyticsModal = document.getElementById('analyticsModal');
            if (analyticsModal && analyticsModal.classList.contains('active')) {
                destroyAnalyticsCharts();
                updateAnalytics();
                createAnalyticsCharts();
            }
        }
        
/**
         * Reset conversation (v0.3.0 - Custom glass modal confirmation)
         */
        async function resetConversation() {
            // v0.3.0: Custom glass confirmation modal
            const confirmed = await showConfirmModal({
                title: 'Reset Conversation',
                message: 'Are you sure you want to reset this conversation? All messages will be lost and cannot be recovered.',
                icon: '🔄',
                confirmText: 'Reset',
                confirmClass: 'btn-danger'
            });

            if (!confirmed) {
                return;
            }

            if (state.running) {
                stopConversation();
            }

            // v0.2.0: Destroy all Chart.js instances to prevent memory leaks
            Object.keys(state.charts).forEach(chartId => {
                if (state.charts[chartId]) {
                    state.charts[chartId].destroy();
                    logDebug(`Chart destroyed: ${chartId}`);
                }
            });
            state.charts = {}; // Clear chart references

            const conv = getCurrentConversation();
            initConversation(conv.id); // Reset conversation object

            state.currentRound = 0;

            clearMessages(); // Empty the container first

            // *** Restore Placeholder Manually ***
            const container = document.getElementById('messagesContainer');
            if (container) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: var(--text-secondary);">
                        <div class="ai-orb" style="margin-bottom: 24px;">
                            <svg width="120" height="120" viewBox="0 0 120 120">
                                <defs>
                                    <linearGradient id="orbGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" stop-color="#6366f1"/>
                                        <stop offset="50%" stop-color="#a78bfa"/>
                                        <stop offset="100%" stop-color="#ec4899"/>
                                    </linearGradient>
                                </defs>
                                <circle cx="60" cy="60" r="50" fill="url(#orbGrad)" opacity="0.8">
                                    <animate attributeName="r" values="48;52;48" dur="4s" repeatCount="indefinite"/>
                                </circle>
                                <circle cx="60" cy="60" r="30" fill="white" opacity="0.1"/>
                                <circle cx="60" cy="60" r="10" fill="white" opacity="0.4">
                                    <animate attributeName="opacity" values="0.4;1;0.4" dur="2s" repeatCount="indefinite"/>
                                </circle>
                            </svg>
                        </div>
                        <h3 style="margin-bottom: 12px; font-size: 1.5em;">Ready to Start</h3>
                        <p style="margin-bottom: 8px;">Configure your agents, enter a task, and click Start to begin the conversation.</p>
                        <p style="margin-top: 16px; font-size: 0.9em; background: var(--bg-light); padding: 12px; border-radius: var(--radius-md); display: inline-block;">
                            💡 Press <kbd style="padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid var(--border-color);">Cmd+K</kbd> or
                            <kbd style="padding: 4px 8px; background: white; border-radius: 4px; border: 1px solid var(--border-color);">Ctrl+K</kbd> to open the command palette
                        </p>
                    </div>
                `;
                 logDebug("resetConversation: Placeholder restored.");
            }
            // *** End Restore Placeholder ***

            document.getElementById('taskInput').value = '';
            document.getElementById('roundCounter').textContent = 'Round: 0';

            updateUIForStopped();

            showToast('Conversation reset', { type: 'info', title: 'Reset' });
            logInfo('Conversation reset');
        }
        
        function exportConversation() {
            const conv = getCurrentConversation();

            const data = {
                version: APP_VERSION,
                exported: new Date().toISOString(),
                conversation: conv,
                agents: state.agents,
                analytics: state.analytics,
                consensusReached: state.consensusReached // v0.4.1: Include consensus status
            };

            downloadJSON(data, `conversation_${conv.id}_${Date.now()}.json`);

            showToast('Conversation exported', { type: 'success', title: 'Exported' });
        }
        
        function newConversation() {
            const id = state.nextConversationId++;
            initConversation(id);
            
            const tabsContainer = document.getElementById('tabsContainer');
            const newTabBtn = tabsContainer.querySelector('.new-tab-btn');
            
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.dataset.conversationId = id;
            tab.onclick = () => switchConversation(id);
            tab.innerHTML = `
                <span>💬 Conversation ${id}</span>
                <span class="tab-close" onclick="closeConversation(${id}, event)" aria-label="Close conversation tab" role="button" tabindex="0">×</span>
            `;
            
            tabsContainer.insertBefore(tab, newTabBtn);
            switchConversation(id);
        }
        
        /* v0.2.0: Enhanced with chart cleanup on tab switch */
        function switchConversation(id) {
            if (state.running) {
                showToast('Cannot switch tabs while a conversation is running', { type: 'warning', title: 'Busy' });
                return;
            }

            // v0.2.0: Destroy charts before switching to prevent crashes
            Object.keys(state.charts).forEach(chartId => {
                if (state.charts[chartId]) {
                    state.charts[chartId].destroy();
                    logDebug(`Chart destroyed on tab switch: ${chartId}`);
                }
            });
            state.charts = {};

            state.activeConversationId = id;

            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active',
                    parseInt(tab.dataset.conversationId) === id
                );
            });

            clearMessages();
            const conv = state.conversations[id];
            if (conv && conv.messages) {
                conv.messages.forEach(msg => displayMessage(msg));
            }

            document.getElementById('roundCounter').textContent =
                `Round: ${conv ? conv.rounds : 0}`;
            document.getElementById('taskInput').value = conv ? conv.task : '';

            updateUIForStopped();
        }

        /* v0.3.0: Custom glass modal confirmation */
        async function closeConversation(id, event) {
            event.stopPropagation();

            if (state.running) {
                showToast('Cannot close tabs while a conversation is running', { type: 'warning', title: 'Busy' });
                return;
            }

            if (Object.keys(state.conversations).length === 1) {
                showToast('Cannot close last conversation', { type: 'warning' });
                return;
            }

            // v0.3.0: Custom glass confirmation modal
            const confirmed = await showConfirmModal({
                title: 'Close Conversation',
                message: 'Are you sure you want to close this conversation tab? It cannot be recovered.',
                icon: '🗑️',
                confirmText: 'Close Tab',
                confirmClass: 'btn-danger'
            });

            if (!confirmed) {
                return;
            }

            delete state.conversations[id];

            const tab = document.querySelector(`[data-conversation-id="${id}"]`);
            if (tab) tab.remove();

            if (state.activeConversationId === id) {
                const remainingId = Object.keys(state.conversations)[0];
                switchConversation(parseInt(remainingId));
            }
        }
        
        /* =================================================================
           UI UTILITIES - (Restored from v0-1-2)
           ================================================================= */
        
        function showToast(message, options = {}) {
            const container = document.getElementById('toastContainer');
            
            const toast = document.createElement('div');
            const type = options.type || 'info';
            const title = options.title || type.charAt(0).toUpperCase() + type.slice(1);
            
            const icons = {
                success: '✅',
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️'
            };
            
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">×</button>
            `;
            
            container.appendChild(toast);
            
            const duration = options.duration || 4000;
            if (duration > 0) {
                 setTimeout(() => {
                    toast.classList.add('removing');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = sidebar.querySelector('.sidebar-toggle');
            state.sidebarCollapsed = !state.sidebarCollapsed;

            if (state.sidebarCollapsed) {
                sidebar.classList.add('collapsed');
                toggleBtn.setAttribute('aria-expanded', 'false');
            } else {
                sidebar.classList.remove('collapsed');
                toggleBtn.setAttribute('aria-expanded', 'true');
            }
            saveState();
        }
        
        function toggleSection(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            content.classList.toggle('collapsed');
        }
        
        function toggleDarkMode(fromButton = false) {
            const toggle = document.getElementById('darkModeToggle');
            if(fromButton) {
                toggle.checked = !toggle.checked;
            }
            document.body.classList.toggle('dark-mode', toggle.checked);
            localStorage.setItem('darkMode', toggle.checked ? '1' : '0');
        }
        
        // ── v0.4.0: MODAL MANAGEMENT WITH CHART.JS LIFECYCLE ──
        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
            if (modalId === 'analyticsModal') {
                updateAnalytics();
                createAnalyticsCharts();
            }
            // v0.4.0: Focus trapping
            trapFocus(modalId);
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            if (modalId === 'analyticsModal') {
                destroyAnalyticsCharts();
            }
            // v0.4.0: Release focus trap
            releaseFocus();
        }

        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }

        function copyMessage(btn) {
            const content = btn.closest('.message').querySelector('.message-content').textContent;
            navigator.clipboard.writeText(content);
            showToast('Message copied to clipboard', { type: 'success', title: 'Copied', duration: 1500 });
        }
        
        function bookmarkMessage(btn) {
            btn.style.opacity = '1';
            btn.textContent = '🌟'; // Change icon to solid star
            showToast('Message bookmarked (feature coming soon)', { type: 'info', title: 'Bookmarked', duration: 1500 });
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            if (typeof text !== 'string') return '';
            const div = document.createElement('div');
            div.textContent = text;
            // Use CSS white-space: pre-wrap instead of replacing \n
            return div.innerHTML;
        }

        function showHelp() {
            const helpText = `
Keyboard Shortcuts:
• Cmd/Ctrl + K: Command Palette
• Space: Start Conversation
• P: Pause Conversation
• Ctrl/Cmd + S: Stop Conversation
• R: Reset Conversation
• E: Export Conversation
• /: Search Messages
• N: New Conversation
• D: Toggle Dark Mode
• S: Toggle Sidebar
• L: Toggle Debug Log
• A: Analytics
            `.trim();
            alert(helpText);
        }

        // --- v0-1-2 Search ---
        function toggleSearch() {
            const searchBar = document.getElementById('searchBar');
            searchBar.classList.toggle('hidden');
            
            if (!searchBar.classList.contains('hidden')) {
                document.getElementById('searchInput').focus();
            } else {
                searchMessages(''); // Clear search when hiding
            }
        }
        
        function searchMessages(query) {
            const messages = document.querySelectorAll('.message');
            const clearBtn = document.getElementById('searchClear');
            
            clearBtn.classList.toggle('visible', query.length > 0);
            
            if (!query) {
                messages.forEach(msg => msg.style.display = '');
                return;
            }
            
            const lowerQuery = query.toLowerCase();
            messages.forEach(msg => {
                const content = msg.querySelector('.message-content').textContent.toLowerCase();
                msg.style.display = content.includes(lowerQuery) ? '' : 'none';
            });
        }
        
        function clearSearch() {
            document.getElementById('searchInput').value = '';
            searchMessages('');
        }

        // --- v0-1-2 Analytics ---
        function updateAnalytics() {
            document.getElementById('totalRounds').textContent = state.analytics.totalRounds;
            document.getElementById('totalMessages').textContent = state.analytics.totalMessages;

            const avgTime = state.analytics.responseTimes.length > 0
                ? state.analytics.responseTimes.reduce((a, b) => a + b.time, 0) / state.analytics.responseTimes.length / 1000
                : 0;
            document.getElementById('avgResponseTime').textContent = `${avgTime.toFixed(1)}s`;

            const total = state.analytics.successCount + state.analytics.failureCount;
            const successRate = total > 0 ? (state.analytics.successCount / total * 100).toFixed(1) : 0;
            document.getElementById('successRate').textContent = `${successRate}%`;

            document.getElementById('totalAttempts').textContent = total;
            document.getElementById('successCount').textContent = state.analytics.successCount;
            document.getElementById('failureCount').textContent = state.analytics.failureCount;

            // v0.4.0: Charts are created/destroyed on modal open/close for proper lifecycle management
        }

        // ── v0.4.0: CHART.JS ANALYTICS CHARTS ──
        // ── v0.4.1: Enhanced with empty state handling and pie chart ──
        function createAnalyticsCharts() {
            const isDarkMode = document.body.classList.contains('dark-mode');
            const textColor = isDarkMode ? '#f1f5f9' : '#0f172a';
            const gridColor = isDarkMode ? 'rgba(148, 163, 184, 0.1)' : 'rgba(0, 0, 0, 0.1)';

            // Destroy existing charts if any
            destroyAnalyticsCharts();

            // v0.4.1: Filter out zero response times (errors/failures)
            const validResponseTimes = state.analytics.responseTimes.filter(rt => rt.time > 0);

            // v0.4.2: Per-chart empty states with specific messages
            if (validResponseTimes.length < 2) {
                const trendContainer = document.getElementById('responseTrendChart')?.parentElement;
                if (trendContainer) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'text-align:center; padding:40px; color:var(--text-secondary); font-size:1.1em;';
                    emptyMsg.innerHTML = '📈 <strong>Only 2 rounds completed</strong> — run more for a meaningful trend';
                    trendContainer.innerHTML = '';
                    trendContainer.appendChild(emptyMsg);
                }
            }

            if (validResponseTimes.length === 0) {
                const barContainer = document.getElementById('responseTimesChart')?.parentElement;
                if (barContainer) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'text-align:center; padding:40px; color:var(--text-secondary); font-size:1.1em;';
                    emptyMsg.innerHTML = '📊 <strong>Limited successful responses</strong> — more rounds needed for agent comparison';
                    barContainer.innerHTML = '';
                    barContainer.appendChild(emptyMsg);
                }
            }

            // Chart 1: Response Time Trend (Line Chart)
            const trendCtx = document.getElementById('responseTrendChart');
            if (trendCtx && validResponseTimes.length >= 2) {
                const trendData = validResponseTimes.map((rt, idx) => ({
                    x: idx + 1,
                    y: (rt.time / 1000).toFixed(2)
                }));

                state.charts.responseTrendChart = new Chart(trendCtx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Response Time (s)',
                            data: trendData,
                            borderColor: '#6366f1',
                            backgroundColor: 'rgba(99, 102, 241, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            x: {
                                type: 'linear',
                                // v0.4.2: Clear axis label
                                title: { display: true, text: 'Round', color: textColor, font: { size: 14, weight: 'bold' } },
                                ticks: { color: textColor },
                                grid: { color: gridColor }
                            },
                            y: {
                                // v0.4.2: Clear axis label
                                title: { display: true, text: 'Seconds (s)', color: textColor, font: { size: 14, weight: 'bold' } },
                                ticks: { color: textColor },
                                grid: { color: gridColor }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: textColor } },
                            // v0.4.2: Enhanced tooltips with exact values
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `Response Time: ${ctx.parsed.y}s`
                                }
                            }
                        }
                    }
                });
            }

            // Chart 2: Average Response Time by Agent (Bar Chart)
            const barCtx = document.getElementById('responseTimesChart');
            if (barCtx && validResponseTimes.length > 0) {
                // v0.4.2: Show ALL agents, including those with no data (gray bar)
                const agentTimes = {};
                validResponseTimes.forEach(rt => {
                    if (!agentTimes[rt.agent]) agentTimes[rt.agent] = [];
                    agentTimes[rt.agent].push(rt.time);
                });

                // v0.4.2: Include all enabled agents
                const allAgentIds = Object.keys(state.agents); // v0.4.3: Use Object.keys for state.agents.map
                const agentLabels = allAgentIds.sort((a, b) => parseInt(a) - parseInt(b));
                const agentAvgs = agentLabels.map(agent => {
                    if (agentTimes[agent]) {
                        const times = agentTimes[agent];
                        return (times.reduce((a, b) => a + b, 0) / times.length / 1000).toFixed(2);
                    }
                    return 0; // No data
                });

                const agentColors = ['#6366f1', '#a78bfa', '#ec4899', '#14b8a6', '#f59e0b', '#3b82f6'];
                const agentBgColors = agentLabels.map((agent, i) => {
                    // v0.4.2: Gray color for agents with no data
                    return agentTimes[agent] ? agentColors[i % agentColors.length] : '#9ca3af';
                });

                state.charts.responseTimesChart = new Chart(barCtx, {
                    type: 'bar',
                    data: {
                        labels: agentLabels.map(a => agentTimes[a] ? `Agent ${a}` : `Agent ${a} (No data)`),
                        datasets: [{
                            label: 'Avg Response Time (s)',
                            data: agentAvgs,
                            backgroundColor: agentBgColors,
                            borderColor: agentBgColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            x: {
                                ticks: { color: textColor },
                                grid: { color: gridColor },
                                // v0.4.2: X-axis label for clarity
                                title: { display: true, text: 'Agent', color: textColor, font: { size: 14, weight: 'bold' } }
                            },
                            y: {
                                // v0.4.2: Y-axis label
                                title: { display: true, text: 'Seconds (s)', color: textColor, font: { size: 14, weight: 'bold' } },
                                ticks: { color: textColor },
                                grid: { color: gridColor }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: textColor } },
                            // v0.4.2: Enhanced tooltips
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        if (ctx.parsed.y === 0) {
                                            return 'No data available';
                                        }
                                        return `Avg Response Time: ${ctx.parsed.y}s`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // v0.4.1: Chart 3: Success Rate Pie Chart
            const pieCtx = document.getElementById('successRateChart');
            if (pieCtx && (state.analytics.successCount > 0 || state.analytics.failureCount > 0)) {
                state.charts.successRateChart = new Chart(pieCtx, {
                    type: 'pie',
                    data: {
                        labels: ['Success', 'Failure'],
                        datasets: [{
                            data: [state.analytics.successCount, state.analytics.failureCount],
                            backgroundColor: ['#10b981', '#ef4444'],
                            borderColor: isDarkMode ? '#1e293b' : '#ffffff',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                labels: { color: textColor },
                                position: 'bottom'
                            },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        const total = state.analytics.successCount + state.analytics.failureCount;
                                        const percent = ((ctx.parsed / total) * 100).toFixed(1);
                                        return `${ctx.label}: ${ctx.parsed} (${percent}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        function destroyAnalyticsCharts() {
            if (state.charts.responseTrendChart) {
                state.charts.responseTrendChart.destroy();
                state.charts.responseTrendChart = null;
            }
            if (state.charts.responseTimesChart) {
                state.charts.responseTimesChart.destroy();
                state.charts.responseTimesChart = null;
            }
            if (state.charts.successRateChart) {
                state.charts.successRateChart.destroy();
                state.charts.successRateChart = null;
            }
        }

        // v0.4.2: Enhanced analytics export with JSON and CSV options
        function exportAnalytics() {
            const data = {
                version: APP_VERSION,
                rounds: state.analytics.rounds,
                totalMessages: state.analytics.totalMessages,
                responseTimes: state.analytics.responseTimes,
                successCount: state.analytics.successCount,
                failureCount: state.analytics.failureCount,
                successRate: (state.analytics.successCount / (state.analytics.successCount + state.analytics.failureCount) * 100).toFixed(1) + '%',
                timestamp: new Date().toISOString()
            };

            // Prompt user for format
            const format = confirm('Export as JSON? (Cancel for CSV)') ? 'json' : 'csv';

            if (format === 'json') {
                downloadJSON(data, `gruper-analytics-${Date.now()}.json`);
            } else {
                // CSV export
                let csv = 'Metric,Value\n';
                csv += `Version,${data.version}\n`;
                csv += `Rounds,${data.rounds}\n`;
                csv += `Total Messages,${data.totalMessages}\n`;
                csv += `Success Count,${data.successCount}\n`;
                csv += `Failure Count,${data.failureCount}\n`;
                csv += `Success Rate,${data.successRate}\n`;
                csv += `Timestamp,${data.timestamp}\n\n`;
                csv += 'Agent,Response Time (ms)\n';
                data.responseTimes.forEach(rt => {
                    csv += `${rt.agent},${rt.time}\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `gruper-analytics-${Date.now()}.csv`;
                a.click();
                URL.revokeObjectURL(url);

                logInfo('Analytics exported as CSV');
                showToast('Analytics data exported as CSV', { type: 'success', title: 'Export Complete' });
            }
        }

        // ── v0.4.0: FOCUS TRAPPING FOR ACCESSIBILITY ──
        let focusTrapElements = [];
        let previousActiveElement = null;

        function trapFocus(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;

            previousActiveElement = document.activeElement;

            // Get all focusable elements in the modal
            const focusableSelectors = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            focusTrapElements = Array.from(modal.querySelectorAll(focusableSelectors));

            if (focusTrapElements.length > 0) {
                focusTrapElements[0].focus();
            }

            modal.addEventListener('keydown', handleFocusTrap);
        }

        function handleFocusTrap(e) {
            if (e.key !== 'Tab' || focusTrapElements.length === 0) return;

            const firstElement = focusTrapElements[0];
            const lastElement = focusTrapElements[focusTrapElements.length - 1];

            if (e.shiftKey) {
                if (document.activeElement === firstElement) {
                    e.preventDefault();
                    lastElement.focus();
                }
            } else {
                if (document.activeElement === lastElement) {
                    e.preventDefault();
                    firstElement.focus();
                }
            }
        }

        function releaseFocus() {
            if (previousActiveElement) {
                previousActiveElement.focus();
                previousActiveElement = null;
            }
            focusTrapElements = [];
        }

        // --- v0-1-2 Command Palette ---
        function openCommandPalette() {
            const overlay = document.getElementById('commandPaletteOverlay');
            const search = document.getElementById('commandSearch');

            overlay.classList.add('active');
            search.value = '';
            search.focus();

            renderCommands(commands);
            // v0.4.0: Focus trapping
            trapFocus('commandPaletteOverlay');
        }

        function closeCommandPalette() {
            document.getElementById('commandPaletteOverlay').classList.remove('active');
            // v0.4.0: Release focus trap
            releaseFocus();
        }
        
        function renderCommands(commandList) {
            const results = document.getElementById('commandResults');
            results.innerHTML = '';
            
            commandList.forEach((cmd, index) => {
                const item = document.createElement('div');
                item.className = `command-item ${index === 0 ? 'selected' : ''}`;
                item.onclick = () => executeCommand(cmd);
                item.innerHTML = `
                    <div class="command-icon">${cmd.icon}</div>
                    <div class="command-details">
                        <div class="command-title">${cmd.title}</div>
                        <div class="command-description">${cmd.description}</div>
                    </div>
                    ${cmd.shortcut ? `<div class="command-shortcut">${cmd.shortcut}</div>` : ''}
                `;
                results.appendChild(item);
            });
        }
        
        function executeCommand(cmd) {
            closeCommandPalette();
            // Check for disabled
            if(cmd.id === 'start' && document.getElementById('startBtn').disabled) return;
            if(cmd.id === 'pause' && document.getElementById('pauseBtn').classList.contains('hidden')) return;
            
            cmd.action();
        }
        
        function filterCommands(query) {
            if (!query) {
                renderCommands(commands);
                return;
            }
            
            const filtered = commands.filter(cmd => 
                cmd.title.toLowerCase().includes(query.toLowerCase()) ||
                cmd.description.toLowerCase().includes(query.toLowerCase())
            );
            
            renderCommands(filtered);
        }
        
        // ── v0.4.1: GLOBAL TIMEOUT HANDLERS ──
        function handleGlobalTimeoutChange() {
            const select = document.getElementById('globalTimeout');
            const customInput = document.getElementById('customGlobalTimeout');

            if (select.value === 'custom') {
                customInput.style.display = 'block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
                const timeout = parseInt(select.value);
                state.connection.timeout.global = timeout;
                saveState();
                logInfo(`Global timeout set to ${timeout / 1000}s`);
            }
        }

        function handleCustomGlobalTimeoutChange() {
            const customInput = document.getElementById('customGlobalTimeout');
            const seconds = parseInt(customInput.value);

            if (seconds >= 60 && seconds <= 3600) {
                state.connection.timeout.global = seconds * 1000;
                saveState();
                logInfo(`Global timeout set to custom ${seconds}s`);
            } else {
                showToast('Timeout must be between 60-3600 seconds', { type: 'warning', title: 'Invalid Value' });
            }
        }

        // ── v0.4.1: TEXT SCALING CONTROL ──
        function setFontScale(scale) {
            state.ui.fontScale = scale;
            document.documentElement.style.setProperty('--font-scale', scale);
            localStorage.setItem('fontScale', scale);
            logInfo(`Font scale set to ${(scale * 100).toFixed(0)}%`);
        }

        function initFontScale() {
            const saved = localStorage.getItem('fontScale');
            if (saved) {
                const scale = parseFloat(saved);
                if (scale >= 0.8 && scale <= 1.4) {
                    setFontScale(scale);
                    // Update dropdown to reflect loaded scale
                    const dropdown = document.getElementById('textSizeControl');
                    if (dropdown) dropdown.value = scale.toString();
                }
            }

            // Suggest smaller scale on mobile/small screens
            if (window.innerWidth < 1000 && !saved) {
                const suggested = 0.9;
                showToast(`Tip: Using ${(suggested * 100).toFixed(0)}% text size for this screen. Adjust in header if needed.`, {
                    type: 'info',
                    title: 'Text Size',
                    duration: 5000
                });
                setFontScale(suggested);
                const dropdown = document.getElementById('textSizeControl');
                if (dropdown) dropdown.value = suggested.toString();
            }
        }

        // ── v0.4.1: RESIZABLE DEBUG LOG ──
        let isResizingDebugLog = false;
        let debugLogStartY = 0;
        let debugLogStartHeight = 0;

        function initDebugLogResize() {
            const panel = document.getElementById('debugLogPanel');
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            handle.title = 'Drag to resize';
            panel.insertBefore(handle, panel.firstChild);

            // Load saved height
            const savedHeight = localStorage.getItem('debugLogHeight');
            if (savedHeight) {
                const height = parseInt(savedHeight);
                if (height >= 200 && height <= window.innerHeight * 0.8) {
                    panel.style.height = `${height}px`;
                    state.ui.debugLogHeight = height;
                }
            }

            handle.addEventListener('mousedown', (e) => {
                isResizingDebugLog = true;
                debugLogStartY = e.clientY;
                debugLogStartHeight = panel.offsetHeight;
                document.body.style.cursor = 'ns-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizingDebugLog) return;
                const deltaY = debugLogStartY - e.clientY;
                const newHeight = Math.max(200, Math.min(window.innerHeight * 0.8, debugLogStartHeight + deltaY));
                panel.style.height = `${newHeight}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isResizingDebugLog) {
                    isResizingDebugLog = false;
                    document.body.style.cursor = '';
                    state.ui.debugLogHeight = panel.offsetHeight;
                    localStorage.setItem('debugLogHeight', panel.offsetHeight);
                    logInfo(`Debug log resized to ${panel.offsetHeight}px`);
                }
            });
        }

        function toggleDebugLogExpand() {
            const panel = document.getElementById('debugLogPanel');
            if (panel.style.height === '80vh') {
                panel.style.height = `${state.ui.debugLogHeight}px`;
            } else {
                panel.style.height = '80vh';
            }
        }

        /* =================================================================
           INITIALIZATION - v0.2.0 Optimized for <80ms load time
           ================================================================= */

        /* v0.2.0: Performance-optimized initialization with lazy loading */
        async function init() {
            // v0.2.0: Start timer to measure init performance
            console.time('init');
            logInfo(`Initializing Multi-Agent System ${APP_VERSION}`);

            // v0.2.0: Critical path - minimal sync operations
            loadState();
            initializeApiClient();
            initConversation(1);
            setupEventListeners();
            setupKeyboardShortcuts();

            // v0.2.0: Batch DOM updates with requestAnimationFrame for 60fps
            requestAnimationFrame(() => {
                if (localStorage.getItem('darkMode') === '1') {
                    document.body.classList.add('dark-mode');
                    const darkToggle = document.getElementById('darkModeToggle');
                    if (darkToggle) darkToggle.checked = true;
                }

                if (state.sidebarCollapsed) {
                    const sidebar = document.getElementById('sidebar');
                    const toggleIcon = document.querySelector('.sidebar-toggle-icon');
                    if (sidebar) sidebar.classList.add('collapsed');
                    if (toggleIcon) toggleIcon.style.transform = 'rotate(180deg)';
                }

                // v0.1.8: Initialize Human-in-the-Loop checkbox state
                const enableHITLCheckbox = document.getElementById('enableHumanInLoop');
                if (enableHITLCheckbox) {
                    enableHITLCheckbox.checked = state.analysis.humanInLoop;
                }

                // v0.3.0: Initialize Consensus checkbox state
                const enableConsensusCheckbox = document.getElementById('enableConsensus');
                if (enableConsensusCheckbox) {
                    enableConsensusCheckbox.checked = state.consensus.enabled;
                }
            });

            // v0.2.0: Defer non-critical UI rendering to next frame
            requestAnimationFrame(() => {
                renderAgentConfig(); // Lazy-load agent config UI
            });

            // v0.4.1: Initialize text scaling and debug log resize
            initFontScale();
            initDebugLogResize();

            // v0.4.1: Restore global timeout dropdown
            const globalTimeoutDropdown = document.getElementById('globalTimeout');
            if (globalTimeoutDropdown && state.connection.timeout.global) {
                const timeout = state.connection.timeout.global;
                const standardValues = [180000, 300000, 600000, 900000];
                if (standardValues.includes(timeout)) {
                    globalTimeoutDropdown.value = timeout.toString();
                } else {
                    globalTimeoutDropdown.value = 'custom';
                    const customInput = document.getElementById('customGlobalTimeout');
                    if (customInput) {
                        customInput.style.display = 'block';
                        customInput.value = (timeout / 1000).toString();
                    }
                }
            }

            // v0.2.0: Async connection test doesn't block init
            testConnection().then(connected => {
                if (connected) {
                    showToast('System ready! Connected to Ollama.', { type: 'success', title: 'System Ready' });
                } else {
                    showToast('System ready. Please connect to Ollama to start.', { type: 'warning', title: 'System Ready' });
                }
            });

            // v0.2.0: Log performance metrics
            console.timeEnd('init');
            logSuccess('System initialized (optimized)', {
                version: APP_VERSION,
                agents: Object.keys(state.agents).length,
                message: 'Init optimized for <80ms load time even with 500 messages'
            });
        }
        
        function setupEventListeners() {
            document.getElementById('darkModeToggle').addEventListener('change', (e) => {
                toggleDarkMode(false);
            });
            
            document.getElementById('enableMemory').addEventListener('change', (e) => {
                state.memory.enabled = e.target.checked;
                saveState();
            });
            
            document.getElementById('memoryDepth').addEventListener('change', (e) => {
                state.memory.depth = parseInt(e.target.value);
                saveState();
            });

            // v0.1.8: Human-in-the-Loop event listener
            document.getElementById('enableHumanInLoop').addEventListener('change', (e) => {
                state.analysis.humanInLoop = e.target.checked;
                saveState();
                logInfo('Human-in-the-Loop ' + (e.target.checked ? 'enabled' : 'disabled'));
            });

            // v0.3.0: Consensus event listener (re-added)
            document.getElementById('enableConsensus').addEventListener('change', (e) => {
                state.consensus.enabled = e.target.checked;
                saveState();
                logInfo('Consensus detection ' + (e.target.checked ? 'enabled' : 'disabled'));
            });

            document.getElementById('maxRounds').addEventListener('change', (e) => {
                saveState();
            });
            
            const autoBtn = document.getElementById('autoReconnectBtn');
            if (autoBtn && state.autoReconnect) {
                autoBtn.classList.add('active');
                autoBtn.style.background = 'var(--success-color)';
                autoBtn.style.color = 'white';
            }
            
            // v0-1-2 Listeners
            document.querySelectorAll('.modal-overlay, .command-palette-overlay').forEach(overlay => {
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.classList.remove('active');
                    }
                });
            });
            
            const messagesContainer = document.getElementById('messagesContainer');
            const scrollBtn = document.getElementById('scrollBottomBtn');
            if(messagesContainer && scrollBtn) {
                messagesContainer.addEventListener('scroll', () => {
                    const nearBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 100;
                    scrollBtn.style.display = nearBottom ? 'none' : 'block';
                });
            }

            document.getElementById('commandSearch').addEventListener('input', (e) => {
                filterCommands(e.target.value);
            });

            // v0.4.2: Debug log search filter
            const debugSearch = document.getElementById('debugSearch');
            if (debugSearch) {
                debugSearch.addEventListener('input', (e) => {
                    renderDebugLog(); // Re-render with filter
                    // Save search term to localStorage
                    localStorage.setItem('debugSearchTerm', e.target.value);
                });

                // Restore search term from localStorage
                const savedSearch = localStorage.getItem('debugSearchTerm');
                if (savedSearch) {
                    debugSearch.value = savedSearch;
                }
            }

            // v0.4.2: Debug log auto-scroll toggle
            const debugAutoScroll = document.getElementById('debugAutoScroll');
            if (debugAutoScroll) {
                debugAutoScroll.addEventListener('change', (e) => {
                    // Save auto-scroll preference to localStorage
                    localStorage.setItem('debugAutoScroll', e.target.checked ? '1' : '0');
                    logInfo('Debug auto-scroll ' + (e.target.checked ? 'enabled' : 'disabled'));
                });

                // Restore auto-scroll preference from localStorage
                const savedAutoScroll = localStorage.getItem('debugAutoScroll');
                if (savedAutoScroll !== null) {
                    debugAutoScroll.checked = savedAutoScroll === '1';
                }
            }

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (state.running) {
                    stopConversation();
                }
                stopHealthCheck();
                stopAutoReconnect();
            });
        }

        // v0-1-2 Keyboard Shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    openCommandPalette();
                    return;
                }
                
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    if (e.key === 'Escape') {
                        e.target.blur();
                        closeCommandPalette();
                        closeModal('analyticsModal');
                        closeModal('templatesModal');
                    }
                    return;
                }
                
                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        if (!state.running && !document.getElementById('startBtn').disabled) startConversation();
                        else if (state.paused) resumeConversation();
                        break;
                    case 'p':
                    case 'P':
                        if (state.running && !state.paused) pauseConversation();
                        break;
                    case 'r':
                    case 'R':
                        if (!document.getElementById('resetBtn').disabled) resetConversation();
                        break;
                    case 'e':
                    case 'E':
                        if (!document.getElementById('exportBtn').disabled) exportConversation();
                        break;
                    case '/':
                        e.preventDefault();
                        toggleSearch();
                        break;
                    case 'n':
                    case 'N':
                        newConversation();
                        break;
                    case 'd':
                    case 'D':
                        toggleDarkMode(true);
                        break;
                    case 's':
                    case 'S':
                        if (e.ctrlKey || e.metaKey) {
                             e.preventDefault();
                             if(state.running) stopConversation();
                        } else {
                            toggleSidebar();
                        }
                        break;
                    case 'a':
                    case 'A':
                        openModal('analyticsModal');
                        break;
                    case 'l':
                    case 'L':
                        toggleDebugLog();
                        break;
                    case 'Escape':
                        closeCommandPalette();
                        closeModal('analyticsModal');
                        closeModal('templatesModal');
                        if (!document.getElementById('searchBar').classList.contains('hidden')) {
                             toggleSearch(); // Close search bar on escape
                        }
                        break;
                }
            });
            
            document.getElementById('commandSearch').addEventListener('keydown', (e) => {
                const items = document.querySelectorAll('.command-item');
                if(!items.length) return;
                const selected = document.querySelector('.command-item.selected');
                let index = selected ? Array.from(items).indexOf(selected) : -1;
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        if (index < items.length - 1) {
                            if(selected) selected.classList.remove('selected');
                            items[index + 1].classList.add('selected');
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if (index > 0) {
                            if(selected) selected.classList.remove('selected');
                            items[index - 1].classList.add('selected');
                        }
                        break;
                    case 'Enter':
                        e.preventDefault();
                        const cmdToRun = selected ? commands.find(c => c.title === selected.querySelector('.command-title').textContent) : commands.find(c => c.title === items[0].querySelector('.command-title').textContent);
                        if (cmdToRun) executeCommand(cmdToRun);
                        break;
                    case 'Escape':
                        closeCommandPalette();
                        break;
                }
            });
        }

        /* =================================================================
           v0.3.0: PROMPT PANEL MINIMIZE TOGGLE
           ================================================================= */
        function togglePromptPanel() {
            const panel = document.getElementById('promptPanel');
            const btn = document.getElementById('minimizePromptBtn');

            if (panel.classList.contains('prompt-panel-minimized')) {
                panel.classList.remove('prompt-panel-minimized');
                btn.textContent = '▼';
                btn.title = 'Minimize prompt panel';
            } else {
                panel.classList.add('prompt-panel-minimized');
                btn.textContent = '▲';
                btn.title = 'Maximize prompt panel';
            }
        }

        /* =================================================================
           v0.3.0: CUSTOM GLASS CONFIRMATION MODAL
           ================================================================= */
        let confirmModalResolver = null;

        function showConfirmModal(options = {}) {
            const {
                title = 'Confirm Action',
                message = 'Are you sure?',
                icon = '⚠️',
                confirmText = 'Confirm',
                confirmClass = 'btn-danger'
            } = options;

            return new Promise((resolve) => {
                confirmModalResolver = resolve;

                const modal = document.getElementById('confirmModal');
                const iconEl = document.getElementById('confirmModalIcon');
                const titleEl = document.getElementById('confirmModalTitle');
                const messageEl = document.getElementById('confirmModalMessage');
                const confirmBtn = document.getElementById('confirmModalConfirmBtn');

                iconEl.textContent = icon;
                titleEl.textContent = title;
                messageEl.textContent = message;
                confirmBtn.textContent = confirmText;

                // Update confirm button class
                confirmBtn.className = `btn ${confirmClass}`;

                modal.classList.add('active');
                // v0.4.0: Focus trapping
                trapFocus('confirmModal');
            });
        }

        function closeConfirmModal(confirmed) {
            const modal = document.getElementById('confirmModal');
            modal.classList.remove('active');

            if (confirmModalResolver) {
                confirmModalResolver(confirmed);
                confirmModalResolver = null;
            }
            // v0.4.0: Release focus trap
            releaseFocus();
        }

        // Close modal on overlay click
        document.addEventListener('click', (e) => {
            if (e.target.id === 'confirmModal') {
                closeConfirmModal(false);
            }
        });

        // Start application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init().catch(error => {
                logError('Failed to initialize', error);
                showToast('Failed to initialize application', {
                    type: 'error',
                    duration: 0
                });
            });
        }
    </script>
</body>
</html>
